
import React, { useState, useEffect } from 'react';
import { GoogleGenAI } from "@google/genai";

export const AffirmationMessage: React.FC = () => {
    const [affirmation, setAffirmation] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        const fetchAffirmation = async () => {
            setIsLoading(true);
            try {
                if (!process.env.API_KEY) {
                    throw new Error("API key not configured.");
                }
                const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
                const prompt = "You are a gentle, wise voice. Provide a single, short, calming affirmation for someone seeking a moment of peace. Do not use quotation marks. Keep it under 15 words.";
                
                const response = await ai.models.generateContent({
                    model: 'gemini-2.5-flash',
                    contents: prompt,
                });

                setAffirmation(response.text);

            } catch (error) {
                console.error("Failed to fetch affirmation:", error);
                setAffirmation("Breathe in, breathe out. You are right where you need to be.");
            } finally {
                setIsLoading(false);
            }
        };

        fetchAffirmation();
    }, []);

    return (
        <div className="absolute inset-0 flex items-center justify-center p-8 bg-black/20 backdrop-blur-sm animate-fade-in z-20">
            <div className="text-center">
                {isLoading ? (
                    <div className="w-8 h-8 border-4 border-white/50 border-t-white rounded-full animate-spin"></div>
                ) : (
                    <p className="text-white text-3xl font-serif italic drop-shadow-lg animate-fade-in">
                        "{affirmation}"
                    </p>
                )}
            </div>
        </div>
    );
};
import React, { useState } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CharacterData } from '../hooks/types';

interface AvatarCustomizerProps {
    character: CharacterData;
    onSave: (newAvatarUrl: string) => void;
    onClose: () => void;
}

export const AvatarCustomizer: React.FC<AvatarCustomizerProps> = ({ character, onSave, onClose }) => {
    const [prompt, setPrompt] = useState(character.basePrompt);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [generatedImage, setGeneratedImage] = useState<string | null>(null);

    const handleGenerate = async () => {
        setIsLoading(true);
        setError(null);
        setGeneratedImage(null);

        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const response = await ai.models.generateImages({
                model: 'imagen-4.0-generate-001',
                prompt: prompt,
                config: {
                    numberOfImages: 1,
                    outputMimeType: 'image/png',
                    aspectRatio: '1:1',
                },
            });
            
            if (response.generatedImages && response.generatedImages.length > 0) {
                const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
                const imageUrl = `data:image/png;base64,${base64ImageBytes}`;
                setGeneratedImage(imageUrl);
            } else {
                setError('No image was generated. Please try a different prompt.');
            }

        } catch (e) {
            console.error(e);
            setError('Failed to generate image. Please try again.');
        } finally {
            setIsLoading(false);
        }
    };
    
    const handleSave = () => {
        if (generatedImage) {
            onSave(generatedImage);
        }
    };

    return (
        <div className="absolute inset-0 bg-slate-900/40 z-30 flex items-center justify-center animate-fade-in p-4 backdrop-blur-lg">
            <div className="relative bg-white/70 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-2xl p-6 md:p-8 transform transition-all animate-fade-in-up max-h-[90vh] flex flex-col font-sans overflow-hidden">
                <div className="flex-shrink-0 flex justify-between items-start">
                    <div>
                        <h2 className="text-2xl font-bold text-slate-800 font-serif">Customize {character.name}</h2>
                        <p className="text-slate-600 mt-1">Describe the new look you want for your character.</p>
                    </div>
                     <button onClick={onClose} className="text-slate-500 hover:text-slate-800 transition-colors p-1 rounded-full hover:bg-black/10">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                           <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2.5" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                <div className="flex-grow mt-6 grid grid-cols-1 md:grid-cols-2 gap-6 overflow-y-auto custom-scrollbar pr-2">
                    <div>
                        <label htmlFor="prompt" className="block text-sm font-medium text-slate-700 mb-1">Prompt</label>
                        <textarea
                            id="prompt"
                            rows={6}
                            value={prompt}
                            onChange={(e) => setPrompt(e.target.value)}
                            className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner text-slate-900 placeholder-slate-500 focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 transition-all"
                            placeholder="e.g., A friendly garden gnome tending to a money tree, cartoon style."
                        />
                         <button
                            onClick={handleGenerate}
                            disabled={isLoading}
                            className="mt-4 w-full px-6 py-3 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-800 transition-all disabled:bg-slate-400 disabled:shadow-none disabled:cursor-not-allowed"
                        >
                            {isLoading ? 'Generating...' : 'Generate Image'}
                        </button>
                    </div>

                    <div className="flex flex-col items-center justify-center bg-slate-500/10 rounded-md p-4 min-h-[200px] border border-slate-500/10 shadow-inner">
                        {isLoading && (
                            <div className="flex flex-col items-center text-slate-500">
                                <svg className="animate-spin h-8 w-8 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <p className="mt-3 text-sm font-medium">Creating magic...</p>
                            </div>
                        )}
                        {error && <p className="text-red-500 text-center font-medium">{error}</p>}
                        {generatedImage && (
                            <img src={generatedImage} alt="Generated avatar" className="w-full h-full object-cover rounded-md shadow-lg animate-fade-in" />
                        )}
                         {!isLoading && !generatedImage && !error && (
                            <div className="text-center text-slate-400">
                                <svg xmlns="http://www.w3.org/2000/svg" className="mx-auto h-10 w-10 opacity-50" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="1.5">
                                  <path strokeLinecap="round" strokeLinejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                </svg>
                                <p className="mt-2 text-sm">Your new avatar will appear here.</p>
                            </div>
                        )}
                    </div>
                </div>

                <div className="flex-shrink-0 mt-6 flex justify-end gap-4 border-t border-slate-900/10 pt-5">
                    <button
                        onClick={onClose}
                        className="px-6 py-2 bg-slate-200/70 text-slate-800 font-semibold rounded-lg hover:bg-slate-300/80 transition-colors focus:outline-none focus:ring-2 focus:ring-slate-400 shadow-sm"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={handleSave}
                        disabled={!generatedImage || isLoading}
                        className="px-6 py-2 bg-emerald-600 text-white font-semibold rounded-lg shadow-md hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-green-400 disabled:bg-emerald-400 disabled:shadow-none disabled:cursor-not-allowed transition-all"
                    >
                        Save Avatar
                    </button>
                </div>
            </div>
        </div>
    );
};
import React, { useState, useEffect, useMemo } from 'react';
import { GENERIC_AVATARS } from './CharacterAvatars';

interface BodyDoubleRoomProps {
    onClose: () => void;
}

const SESSION_DURATION = 25 * 60; // 25 minutes in seconds

export const BodyDoubleRoom: React.FC<BodyDoubleRoomProps> = ({ onClose }) => {
    const [secondsLeft, setSecondsLeft] = useState(SESSION_DURATION);
    const [isActive, setIsActive] = useState(false);

    const simulatedUsers = useMemo(() => 
        Array.from({ length: 5 }).map((_, i) => ({
            id: i,
            Avatar: GENERIC_AVATARS[i % GENERIC_AVATARS.length],
            style: {
                animation: `pulse-glow ${4 + Math.random() * 4}s infinite ${Math.random() * 2}s`,
            }
        }))
    , []);

    useEffect(() => {
        let interval: NodeJS.Timeout | null = null;
        if (isActive && secondsLeft > 0) {
            interval = setInterval(() => {
                setSecondsLeft(prev => prev - 1);
            }, 1000);
        } else if (secondsLeft === 0) {
            setIsActive(false);
            // Optionally play a sound or show a notification
        }
        return () => {
            if (interval) clearInterval(interval);
        };
    }, [isActive, secondsLeft]);

    const toggleTimer = () => {
        if (secondsLeft === 0) {
            setSecondsLeft(SESSION_DURATION);
        }
        setIsActive(prev => !prev);
    };

    const resetTimer = () => {
        setIsActive(false);
        setSecondsLeft(SESSION_DURATION);
    }

    const minutes = Math.floor(secondsLeft / 60);
    const seconds = secondsLeft % 60;

    return (
        <div className="fixed inset-0 bg-black/30 z-40 flex items-center justify-center p-4 animate-fade-in backdrop-blur-md" onClick={onClose}>
            <div className="relative bg-white/70 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-2xl p-6 text-center transform transition-all animate-fade-in-up font-sans" onClick={(e) => e.stopPropagation()}>
                <div className="flex items-center gap-3 mb-2 justify-center">
                    <span className="text-3xl" aria-hidden="true">üë•</span>
                    <h2 className="text-3xl font-bold text-slate-800 font-serif">Body Double Room</h2>
                </div>
                <p className="text-slate-600 mb-6">A quiet space to work alongside others. Start the timer and begin.</p>
                
                <div className="my-8">
                    <p className="font-mono text-7xl font-bold text-slate-800 tracking-tighter" role="timer" aria-live="assertive">
                        {String(minutes).padStart(2, '0')}:{String(seconds).padStart(2, '0')}
                    </p>
                </div>

                <div className="flex justify-center gap-4 mb-8">
                    <button onClick={toggleTimer} className={`px-8 py-3 text-white font-semibold rounded-lg shadow-md transition-all w-40 ${isActive ? 'bg-rose-600 hover:bg-rose-700' : 'bg-sky-700 hover:bg-sky-800'}`}>
                        {isActive ? 'Pause Session' : secondsLeft === 0 ? 'Start New Session' : 'Start Session'}
                    </button>
                    <button onClick={resetTimer} className="px-6 py-3 bg-slate-200/70 text-slate-800 font-semibold rounded-lg hover:bg-slate-300/80 transition-colors shadow-sm">
                        Reset
                    </button>
                </div>

                <div className="relative h-24 border-t border-b border-white/50 bg-black/5 flex items-center justify-center">
                    <p className="absolute top-2 left-4 text-xs font-semibold text-slate-500 uppercase">Focus Session In Progress</p>
                    <div className="flex items-center gap-6">
                        {simulatedUsers.map(user => (
                            <div key={user.id} className="w-12 h-12" style={user.style} title="Another user focusing">
                                <user.Avatar />
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};
import React, { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { CapturedItem } from '../hooks/types';

interface BossBattleProps {
    quest: CapturedItem;
    onClose: () => void;
    onComplete: (questId: string) => void;
}

interface HitPoint {
    id: string;
    text: string;
    isComplete: boolean;
}

export const BossBattle: React.FC<BossBattleProps> = ({ quest, onClose, onComplete }) => {
    const [hitPoints, setHitPoints] = useState<HitPoint[]>([]);
    const [newHitPoint, setNewHitPoint] = useState('');
    const [isVictory, setIsVictory] = useState(false);

    const totalHitPoints = hitPoints.length;
    const completedHitPoints = hitPoints.filter(hp => hp.isComplete).length;
    const bossHealth = totalHitPoints > 0 ? (1 - (completedHitPoints / totalHitPoints)) * 100 : 100;

    useEffect(() => {
        if (totalHitPoints > 0 && completedHitPoints === totalHitPoints) {
            const timer = setTimeout(() => {
                setIsVictory(true);
            }, 500);
            return () => clearTimeout(timer);
        }
    }, [completedHitPoints, totalHitPoints]);


    const handleAddHitPoint = (e: React.FormEvent) => {
        e.preventDefault();
        if (newHitPoint.trim()) {
            setHitPoints(prev => [...prev, { id: uuidv4(), text: newHitPoint.trim(), isComplete: false }]);
            setNewHitPoint('');
        }
    };

    const toggleHitPoint = (id: string) => {
        setHitPoints(prev => prev.map(hp => hp.id === id ? { ...hp, isComplete: !hp.isComplete } : hp));
    };

    const handleVictoryClose = () => {
        onComplete(quest.id);
    };

    if (isVictory) {
        return (
             <div className="fixed inset-0 bg-black/30 z-40 flex items-center justify-center p-4 animate-fade-in backdrop-blur-md">
                <div className="relative bg-white/80 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-md p-8 text-center transform transition-all animate-fade-in-up font-sans">
                    <span className="text-6xl">üèÜ</span>
                    <h2 className="text-3xl font-bold text-slate-800 font-serif mt-4">Quest Complete!</h2>
                    <p className="text-slate-600 mt-2">You successfully tackled:</p>
                    <p className="font-semibold text-slate-700 mt-1 mb-6">"{quest.text}"</p>
                    <button onClick={handleVictoryClose} className="px-8 py-3 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold rounded-lg shadow-md">
                        Claim Your Trophy
                    </button>
                </div>
            </div>
        )
    }

    return (
        <div className="fixed inset-0 bg-black/30 z-40 flex items-center justify-center p-4 animate-fade-in backdrop-blur-md" onClick={onClose}>
            <div className="relative bg-white/70 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-xl p-6 transform transition-all animate-fade-in-up font-sans flex flex-col max-h-[90vh]" onClick={(e) => e.stopPropagation()}>
                <div className="flex-shrink-0 text-center">
                    <h2 className="text-2xl font-bold text-slate-800 font-serif">Boss Battle</h2>
                    <p className="text-slate-600 mt-1">Defeat this dreaded quest by breaking it down.</p>
                    <p className="font-semibold text-lg text-slate-800 bg-slate-100/50 border border-slate-200/50 py-2 px-4 rounded-lg my-4">"{quest.text}"</p>
                    
                    {/* Boss Health Bar */}
                    <div className="w-full bg-slate-300 rounded-full h-6 my-4 shadow-inner border border-white/50">
                        <div 
                            className="bg-sky-500 h-full rounded-full transition-all duration-500 ease-out text-right pr-2 text-white font-bold text-sm flex items-center justify-end"
                            style={{ width: `${bossHealth}%` }}
                        >
                           <span className="drop-shadow-sm">{Math.round(bossHealth)}%</span>
                        </div>
                    </div>
                </div>

                <div className="flex-grow my-4 overflow-y-auto custom-scrollbar pr-2 space-y-2">
                    <h3 className="font-semibold text-slate-700">Hit Points (Sub-tasks)</h3>
                    {hitPoints.map(hp => (
                        <div key={hp.id} className={`p-2 rounded-md flex items-center gap-3 transition-all ${hp.isComplete ? 'bg-green-100/50 text-slate-500 line-through' : 'bg-white/60'}`}>
                            <input type="checkbox" checked={hp.isComplete} onChange={() => toggleHitPoint(hp.id)} className="w-5 h-5 rounded text-green-500 focus:ring-green-400" />
                            <label className="flex-grow">{hp.text}</label>
                        </div>
                    ))}
                     {!hitPoints.length && <p className="text-sm text-slate-500 text-center py-4">No hit points yet. Add the first tiny step!</p>}
                </div>
                
                <form onSubmit={handleAddHitPoint} className="flex-shrink-0 flex gap-2 pt-4 border-t border-white/50">
                    <input 
                        type="text" 
                        value={newHitPoint}
                        onChange={e => setNewHitPoint(e.target.value)}
                        placeholder="Add a tiny, easy first step..."
                        className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner"
                    />
                    <button type="submit" className="px-4 py-2 bg-slate-700 text-white font-semibold rounded-md hover:bg-slate-800 transition-colors">Add</button>
                </form>

            </div>
        </div>
    );
};
import React, { useState, useEffect, useRef } from 'react';

// Non-standard browser API, so we need to declare it
declare global {
    interface Window {
        SpeechRecognition: any;
        webkitSpeechRecognition: any;
    }
}

interface CaptureButtonProps {
    onCapture: (text: string) => void;
    isOpen: boolean;
    onToggle: () => void;
    showButton: boolean;
}

export const CaptureButton: React.FC<CaptureButtonProps> = ({ onCapture, isOpen, onToggle, showButton }) => {
    const [text, setText] = useState('');
    const [isListening, setIsListening] = useState(false);
    const recognitionRef = useRef<any>(null);
    const inputRef = React.useRef<HTMLTextAreaElement>(null);

    useEffect(() => {
        if (isOpen) {
            inputRef.current?.focus();
        }
    }, [isOpen]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (text.trim()) {
            onCapture(text.trim());
            setText('');
        }
    };

    const handleMicClick = () => {
        if (isListening) {
            recognitionRef.current?.stop();
            setIsListening(false);
            return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            alert("Sorry, your browser doesn't support speech recognition.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onstart = () => {
            setIsListening(true);
        };

        recognition.onend = () => {
            setIsListening(false);
        };

        recognition.onresult = (event: any) => {
            let interimTranscript = '';
            let finalTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    finalTranscript += event.results[i][0].transcript;
                } else {
                    interimTranscript += event.results[i][0].transcript;
                }
            }
            setText(text + finalTranscript + interimTranscript);
        };
        
        recognition.onerror = (event: any) => {
            console.error('Speech recognition error', event.error);
            setIsListening(false);
        };

        recognition.start();
        recognitionRef.current = recognition;
    };

    useEffect(() => {
        return () => {
            recognitionRef.current?.stop();
        };
    }, []);

    return (
        <div className="fixed bottom-8 right-8 z-30">
            {isOpen && (
                <div 
                className="fixed inset-0 bg-black/30 flex items-center justify-center p-4 animate-fade-in backdrop-blur-md" 
                style={{ zIndex: 9001 }} 
                onClick={onToggle} 
                onMouseDown={(e) => e.stopPropagation()}>
                    <form onSubmit={handleSubmit} className="relative w-full max-w-lg bg-white/80 backdrop-blur-md p-6 rounded-2xl shadow-2xl animate-fade-in-up" onClick={e => e.stopPropagation()}>
                        <label htmlFor="capture-input" className="block text-lg font-semibold text-slate-800 font-serif">Capture a "Brain Bean"</label>
                        <p className="text-slate-600 text-sm mb-4">An idea, a to-do, a worry... get it out of your head.</p>
                        <div className="relative">
                             <textarea
                                ref={inputRef}
                                id="capture-input"
                                value={text}
                                onChange={(e) => setText(e.target.value)}
                                className="w-full p-3 pr-12 bg-white/60 border-2 border-slate-300/40 rounded-lg shadow-inner"
                                rows={4}
                                placeholder="What's on your mind?"
                            />
                            <button 
                                type="button"
                                onClick={handleMicClick}
                                className={`absolute top-3 right-3 p-2 rounded-full transition-colors ${isListening ? 'bg-red-500 text-white animate-pulse' : 'bg-slate-200/50 text-slate-600 hover:bg-slate-300/70'}`}
                                title="Transcribe speech"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M7 4a3 3 0 016 0v6a3 3 0 11-6 0V4z" />
                                    <path d="M5.5 10.5a.5.5 0 01.5.5v1a4 4 0 004 4h0a4 4 0 004-4v-1a.5.5 0 011 0v1a5 5 0 01-4.5 4.975V19h2a.5.5 0 010 1h-5a.5.5 0 010-1h2v-1.525A5 5 0 014.5 12v-1a.5.5 0 01.5-.5z" />
                                </svg>
                            </button>
                        </div>
                        <button type="submit" className="mt-4 w-full px-4 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md transition-colors">
                            Capture
                        </button>
                    </form>
                </div>
            )}
            {showButton && (
                <button
                    onClick={onToggle}
                    className="w-16 h-16 bg-slate-800 hover:bg-slate-700 rounded-full text-white shadow-lg flex items-center justify-center transform hover:scale-110 transition-transform duration-300"
                    aria-label={isOpen ? "Close capture form" : "Open capture form"}
                    title={isOpen ? "Close capture form" : "Open capture form"}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                    </svg>
                </button>
            )}
        </div>
    );
};
import React from 'react';
import { CharacterData, HubId } from '../hooks/types';

interface CharacterProps {
    character: CharacterData;
    onClick: () => void;
    isSanctuary: boolean;
    hasProcrastinationAlert?: boolean;
}

export const Character = React.forwardRef<HTMLDivElement, CharacterProps>(({ character, onClick, isSanctuary, hasProcrastinationAlert }, ref) => {
    const AvatarComponent = character.avatar;
    const isCEO = character.id === HubId.SisterMary;
    const sizeClass = isCEO ? 'w-28 h-28' : 'w-24 h-24';

    return (
        <div
            ref={ref}
            className={`group relative flex flex-col items-center cursor-pointer transform transition-transform duration-300 hover:scale-110 ${sizeClass} animate-[idle-bob_5s_ease-in-out_infinite]`}
            style={{ animationDelay: `${Math.random() * 1}s`}}
            onClick={onClick}
            title={`Chat with ${character.name}`}
        >
            <div className={`relative w-full h-full drop-shadow-lg rounded-full overflow-hidden p-1 bg-slate-200/80 shadow-lg ${isSanctuary ? 'grayscale' : ''}`}>
                 <div className="w-full h-full rounded-full overflow-hidden ring-2 ring-slate-700/80">
                    {typeof AvatarComponent === 'string' 
                        ? <img src={AvatarComponent} alt={character.name} className="w-full h-full object-cover" />
                        : <AvatarComponent className="w-full h-full" />
                    }
                </div>
                 {hasProcrastinationAlert && character.id === HubId.SisterMary && (
                    <div className="absolute top-0 right-0 bg-white rounded-full p-1 shadow-lg animate-fade-in">
                        <div className="w-6 h-6 text-slate-600">
                             <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                <path strokeLinecap="round" strokeLinejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                            </svg>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
});
import React from 'react';

export const SisterMaryAvatar: React.FC<{className?: string}> = ({className}) => (
    <svg viewBox="0 0 100 100" className={className} xmlns="http://www.w3.org/2000/svg">
        <g>
            {/* Background Circle */}
            <circle cx="50" cy="50" r="48" fill="#E2E8F0" />
            
            {/* Black Veil */}
            <path d="M 50 15 C 20 15, 15 40, 15 50 L 15 80 C 35 95, 65 95, 85 80 L 85 50 C 85 40, 80 15, 50 15 Z" fill="#1F2937" transform="translate(0, -2)" />
            
            {/* White Habit (Wimple covering neck and tunic base) */}
            <path d="M 30 38 L 22 55 C 22 80, 35 90, 50 90 C 65 90, 78 80, 78 55 L 70 38 Z" fill="#FFFFFF" />
            <rect x="20" y="85" width="60" height="15" fill="#FFFFFF" />

            {/* White Cape (Scapular/Capelet) */}
            <path d="M 32 78 C 30 72, 70 72, 68 78 L 75 98 C 60 102, 40 102, 25 98 Z" fill="#FFFFFF" stroke="#D1D5DB" strokeWidth="0.5" />
            
            {/* White Coif (Forehead band) */}
            <path d="M 30 28 C 30 22, 70 22, 70 28 L 70 38 L 30 38 Z" fill="#FFFFFF" />
            
            {/* Face */}
            <ellipse cx="50" cy="53" rx="18" ry="22" fill="#F3DAB9" />
            
            {/* Hair */}
            <path d="M 48 35 C 50 33, 52 33, 54 35 L 51 38 Z" fill="#BDBDBD" stroke="#9E9E9E" strokeWidth="0.5" />

            {/* Eyebrows */}
            <path d="M 38 44 Q 42 42, 46 44" stroke="#4A3731" strokeWidth="1.5" fill="none" />
            <path d="M 54 44 Q 58 42, 62 44" stroke="#4A3731" strokeWidth="1.5" fill="none" />

            {/* Eyes (blue) */}
            <ellipse cx="43" cy="50" rx="3" ry="4" fill="#3B82F6" />
            <ellipse cx="57" cy="50" rx="3" ry="4" fill="#3B82F6" />
            <circle cx="44" cy="48" r="0.75" fill="white" opacity="0.9" />
            <circle cx="58" cy="48" r="0.75" fill="white" opacity="0.9" />
            
            {/* Glasses */}
            <g fill="none" stroke="#262626" strokeWidth="1.75">
                <rect x="36" y="44" width="13" height="11" rx="3" />
                <rect x="51" y="44" width="13" height="11" rx="3" />
                <path d="M49 48 h2" /> {/* Bridge */}
            </g>
            
            {/* Mouth */}
            <path d="M 48 63 Q 50 68, 52 63" stroke="#A56A53" strokeWidth="1.5" fill="none" />

            {/* Rosy Cheeks */}
            <circle cx="38" cy="58" r="4" fill="#E5B8AF" opacity="0.5" />
            <circle cx="62" cy="58" r="4" fill="#E5B8AF" opacity="0.5" />
        </g>
    </svg>
);


export const SoniaAvatar: React.FC<{className?: string}> = ({className}) => (
    <svg viewBox="0 0 100 100" className={className} xmlns="http://www.w3.org/2000/svg">
        <g>
            {/* Background */}
            <circle cx="50" cy="50" r="48" fill="#BAE6FD" />

            {/* Torso/Blazer */}
            <path d="M 30 80 C 40 70, 60 70, 70 80 L 70 100 L 30 100 Z" fill="#4A5568" />
            <path d="M 45 80 L 55 80 L 50 90 Z" fill="#FFFFFF" />
            <path d="M 30 80 L 45 80 L 50 70 L 30 75 Z" fill="#2C5282" />
            <path d="M 70 80 L 55 80 L 50 70 L 70 75 Z" fill="#2C5282" />

            {/* Neck */}
            <rect x="45" y="65" width="10" height="15" fill="#F3D1A0" />

            {/* Face */}
            <ellipse cx="50" cy="48" rx="25" ry="28" fill="#F3D1A0" />

            {/* Hair */}
            <path d="M 25 20 C 10 30, 20 70, 40 75 C 20 80, 20 50, 25 20" fill="#F7DC6F" />
            <path d="M 75 20 C 90 30, 80 70, 60 75 C 80 80, 80 50, 75 20" fill="#F7DC6F" />
            <path d="M 25 20 Q 50 5, 75 20 L 70 15 Q 50 1, 30 15 Z" fill="#FAD7A0" />

            {/* Eyes */}
            <ellipse cx="40" cy="45" rx="5" ry="6" fill="white" />
            <ellipse cx="60" cy="45" rx="5" ry="6" fill="white" />
            <circle cx="40" cy="46" r="3" fill="#3498DB" />
            <circle cx="60" cy="46" r="3" fill="#3498DB" />
            <circle cx="41" cy="45" r="1" fill="white" opacity="0.8" />
            <circle cx="61" cy="45" r="1" fill="white" opacity="0.8" />

            {/* Eyebrows */}
            <path d="M 35 38 Q 40 35, 45 38" stroke="#AF601A" strokeWidth="2" fill="none" />
            <path d="M 55 38 Q 60 35, 65 38" stroke="#AF601A" strokeWidth="2" fill="none" />

            {/* Mouth */}
            <path d="M 40 60 Q 50 68, 60 60 Q 50 65, 40 60" fill="#E74C3C" />
            <path d="M 42 61 Q 50 64, 58 61" stroke="white" strokeWidth="1.5" fill="none" />
        </g>
    </svg>
);


export const FiNancyAvatar: React.FC<{className?: string}> = ({className}) => (
  <svg viewBox="0 0 100 100" className={className}>
        <g>
            <circle cx="50" cy="50" r="48" fill="#BBF7D0" />
            <path d="M 30 50 C 10 80, 90 80, 70 50" fill="#A2B4A3" />
            
            {/* Beard */}
            <path d="M 30 55 C -20 100, 120 100, 70 55 C 50 80, 50 55, 30 55 Z" fill="#BDBDBD" />
            
            {/* Face */}
            <circle cx="50" cy="50" r="20" fill="#F3D1A0" />

            {/* Hair */}
            <path d="M 30 35 C 30 20, 70 20, 70 35" fill="#9E9E9E" />
            
            {/* Features */}
            <circle cx="43" cy="48" r="2.5" fill="#333" />
            <circle cx="57" cy="48" r="2.5" fill="#333" />
            <path d="M 48 58 Q 50 62, 52 58" stroke="#5C3D2E" strokeWidth="1.5" fill="none" />
            
            {/* Eyebrows */}
            <path d="M 38 42 Q 43 40, 48 42" stroke="#757575" strokeWidth="2" fill="none" />
            <path d="M 52 42 Q 57 40, 62 42" stroke="#757575" strokeWidth="2" fill="none" />
        </g>
  </svg>
);

export const PepAvatar: React.FC<{className?: string}> = ({className}) => (
  <svg viewBox="0 0 100 100" className={className}>
        <g>
            <circle cx="50" cy="50" r="48" fill="#FECDD3" />
            <path d="M 40 90 C 50 78, 70 78, 60 90" fill="#C4A4C4" />
            
            {/* Hair */}
            <path d="M 25 50 C 10 20, 50 10, 50 25 C 50 10, 90 20, 75 50 C 100 70, 0 70, 25 50 Z" fill="#E11D48" />

            {/* Face */}
            <circle cx="50" cy="58" r="25" fill="#F3D1A0" />
            
            {/* Features */}
            <path d="M 42 55 Q 45 52, 48 55" stroke="#333" strokeWidth="1.5" fill="none" />
            <path d="M 52 55 Q 55 52, 58 55" stroke="#333" strokeWidth="1.5" fill="none" />
            <path d="M 45 68 Q 50 75, 55 68" stroke="#5C3D2E" strokeWidth="2" fill="none" />
        </g>
  </svg>
);

export const JakeAvatar: React.FC<{className?: string}> = ({className}) => (
    <svg viewBox="0 0 100 100" className={className} xmlns="http://www.w3.org/2000/svg">
        <g>
            {/* Background */}
            <circle cx="50" cy="50" r="48" fill="#A7F3D0" />
            
            {/* Shirt */}
            <path d="M 25 85 C 35 78, 65 78, 75 85 V 100 H 25 Z" fill="#374151" />
            
            {/* Neck */}
            <rect x="45" y="70" width="10" height="15" fill="#F3DAB9" />
            
            {/* Face */}
            <ellipse cx="50" cy="52" rx="24" ry="26" fill="#F3DAB9" />
            
            {/* Stubble */}
            <path d="M 35 62 C 40 73, 60 73, 65 62 Q 50 78 35 62" fill="#000000" opacity="0.1" />

            {/* Hair */}
            <g>
                <path d="M 20 40 C 5 50, 10 90, 30 80 C 25 60, 45 25, 50 20 C 55 25, 75 60, 70 80 C 90 90, 95 50, 80 40 C 65 15, 35 15, 20 40 Z" fill="#5D4037" />
                <path d="M 25 42 C 15 50, 20 75, 35 75 C 30 60, 48 35, 50 28 C 52 35, 70 60, 65 75 C 80 75, 85 50, 75 42 C 68 25, 55 25, 50 25 C 45 25, 32 25, 25 42 Z" fill="#8D6E63" />
            </g>
            
            {/* Eyes */}
            <g>
                <ellipse cx="40" cy="50" rx="4" ry="5" fill="white" />
                <ellipse cx="60" cy="50" rx="4" ry="5" fill="white" />
                <circle cx="40" cy="51" r="2.5" fill="#4A3731" />
                <circle cx="60" cy="51" r="2.5" fill="#4A3731" />
                <circle cx="41" cy="49" r="1" fill="white" opacity="0.8" />
                <circle cx="61" cy="49" r="1" fill="white" opacity="0.8" />
            </g>
            
            {/* Eyebrows */}
            <path d="M 34 43 Q 40 40, 46 43" stroke="#4A3731" strokeWidth="2" fill="none" />
            <path d="M 54 43 Q 60 40, 66 43" stroke="#4A3731" strokeWidth="2" fill="none" />
            
            {/* Mouth (Toothy Smile) */}
            <path d="M 40 65 Q 50 72, 60 65 Q 50 68, 40 65" fill="#FFFFFF" />
            <path d="M 40 65 Q 50 72, 60 65" stroke="#A56A53" strokeWidth="1.5" fill="none" />
        </g>
    </svg>
);


// Generic Avatars for Body Double Room - keeping these simple
const GenericAvatar1: React.FC<{className?: string}> = ({className}) => (
    <div className={`w-full h-full rounded-full overflow-hidden shadow-inner ${className} bg-slate-200`}>
        <svg viewBox="0 0 100 100" className="w-full h-full">
            <circle cx="50" cy="50" r="20" className="fill-slate-400" />
        </svg>
    </div>
);
const GenericAvatar2: React.FC<{className?: string}> = ({className}) => (
    <div className={`w-full h-full rounded-full overflow-hidden shadow-inner ${className} bg-teal-200`}>
        <svg viewBox="0 0 100 100" className="w-full h-full">
            <rect x="30" y="30" width="40" height="40" className="fill-teal-500" />
        </svg>
    </div>
);
const GenericAvatar3: React.FC<{className?: string}> = ({className}) => (
     <div className={`w-full h-full rounded-full overflow-hidden shadow-inner ${className} bg-indigo-200`}>
        <svg viewBox="0 0 100 100" className="w-full h-full">
            <path d="M 50 30 L 70 70 L 30 70 Z" className="fill-indigo-500" />
        </svg>
    </div>
);
const GenericAvatar4: React.FC<{className?: string}> = ({className}) => (
     <div className={`w-full h-full rounded-full overflow-hidden shadow-inner ${className} bg-rose-200`}>
        <svg viewBox="0 0 100 100" className="w-full h-full">
            <path d="M 50 35 C 70 35, 70 65, 50 65 C 30 65, 30 35, 50 35" className="fill-rose-400" />
            <path d="M 50 40 C 65 40, 65 60, 50 60 C 35 60, 35 40, 50 40" className="fill-rose-500" />
        </svg>
    </div>
);

export const GENERIC_AVATARS = [GenericAvatar1, GenericAvatar2, GenericAvatar3, GenericAvatar4];
import React, { useState } from 'react';

export const CommitmentContract: React.FC = () => {
    const [goal, setGoal] = useState('');
    const [deadline, setDeadline] = useState('');
    const [stake, setStake] = useState('');
    const [referee, setReferee] = useState('');
    const [contractText, setContractText] = useState('');

    const generateContract = () => {
        if (!goal || !deadline || !stake || !referee) {
            setContractText("Please fill out all fields to generate the contract.");
            return;
        }

        const text = `**Commitment Contract**

I, the undersigned, do hereby commit to the following goal:
**Goal:** ${goal}

I will achieve this goal by the following date:
**Deadline:** ${deadline}

If I fail to achieve this goal by the deadline, I will honor the following stake:
**Stake:** ${stake}

My chosen accountability partner and referee for this contract is:
**Referee:** ${referee}

I will provide my referee with proof of completion by the deadline. The referee's judgment is final.

Signed,
The Captain`;
        setContractText(text);
    };

    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center gap-3 mb-4">
                <span className="text-3xl" aria-hidden="true">üìú</span>
                <h2 className="text-2xl font-bold text-slate-700 font-serif">Commitment Contract</h2>
            </div>
            <p className="text-slate-600 mb-4 text-sm">Formalize your intentions. A commitment made public is harder to break.</p>
            
            <div className="space-y-4">
                <input type="text" value={goal} onChange={e => setGoal(e.target.value)} placeholder="What is your ambitious goal?" className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner" />
                <input type="text" value={deadline} onChange={e => setDeadline(e.target.value)} placeholder="What is the deadline? (e.g., End of quarter)" className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner" />
                <input type="text" value={stake} onChange={e => setStake(e.target.value)} placeholder="What is the stake if you fail? (e.g., Donate $50)" className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner" />
                <input type="text" value={referee} onChange={e => setReferee(e.target.value)} placeholder="Who is your accountability referee?" className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner" />
            </div>

            <button onClick={generateContract} className="mt-4 w-full px-6 py-2 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-800 transition-colors">
                Generate Contract
            </button>

            {contractText && (
                <div className="mt-4 p-4 bg-stone-100/50 rounded-lg border border-stone-200/50">
                    <h3 className="font-semibold text-slate-700 mb-2">Copy this text and send it to your referee:</h3>
                    <textarea 
                        readOnly
                        value={contractText}
                        rows={10}
                        className="w-full p-2 bg-white/80 border border-slate-300/40 rounded-md text-sm font-mono"
                    />
                </div>
            )}
        </div>
    );
};
import React, { useState, useEffect } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import { CapturedItem, TimeBlock } from '../hooks/types';
import { SoniaAvatar } from './CharacterAvatars';

interface DailyDigestProps {
    questItems: CapturedItem[];
    timeBlocks: TimeBlock[];
    onClose: () => void;
}

interface DigestContent {
    greeting: string;
    topQuests: { text: string }[];
    appointments: { text: string }[];
    quote: string;
}

export const DailyDigest: React.FC<DailyDigestProps> = ({ questItems, timeBlocks, onClose }) => {
    const [isLoading, setIsLoading] = useState(true);
    const [digest, setDigest] = useState<DigestContent | null>(null);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const generateDigest = async () => {
            setIsLoading(true);
            setError(null);

            try {
                if (!process.env.API_KEY) {
                    throw new Error("API key not configured.");
                }

                const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });

                // Get today's date and filter today's time blocks
                const now = new Date();
                const today_hours = now.getHours() + now.getMinutes()/60;
                const todaysBlocks = timeBlocks.filter(block => {
                    // Simple check for non-recurring blocks happening "today" (after current time)
                    return block.recurring === 'none' && block.startHour >= today_hours;
                    // In a real app, date logic would be more complex
                }).map(b => `${b.title} at ${Math.floor(b.startHour)}:${(b.startHour % 1 * 60).toString().padStart(2, '0')}`);

                const prompt = `You are Sonia, a sharp, kind, and clever Chief of Staff. It's the beginning of the day. Generate a "Daily Digest" for the user.
                
                Analyze the user's current quests and today's appointments.
                - Quests: ${questItems.length > 0 ? JSON.stringify(questItems.map(q => q.text)) : "No quests today."}
                - Today's Appointments: ${todaysBlocks.length > 0 ? JSON.stringify(todaysBlocks) : "No appointments scheduled for the rest of today."}

                Your response must be a JSON object with the following structure:
                - greeting: A warm and professional opening.
                - topQuests: An array of objects, each with a 'text' property. Select the 3 most important quests. If fewer than 3 exist, return all of them. If none, return an empty array.
                - appointments: An array of objects, each with a 'text' property, listing today's upcoming appointments. If none, return an empty array.
                - quote: A short, insightful, and motivational quote for the day, fitting your persona.`;
                
                const response = await ai.models.generateContent({
                    model: 'gemini-2.5-flash',
                    contents: prompt,
                    config: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: Type.OBJECT,
                            properties: {
                                greeting: { type: Type.STRING },
                                topQuests: { 
                                    type: Type.ARRAY, 
                                    items: { 
                                        type: Type.OBJECT,
                                        properties: { text: { type: Type.STRING } },
                                        required: ["text"]
                                    } 
                                },
                                appointments: { 
                                    type: Type.ARRAY, 
                                    items: {
                                        type: Type.OBJECT,
                                        properties: { text: { type: Type.STRING } },
                                        required: ["text"]
                                    }
                                },
                                quote: { type: Type.STRING }
                            },
                            required: ["greeting", "topQuests", "appointments", "quote"]
                        }
                    }
                });
                
                setDigest(JSON.parse(response.text));

            } catch (e) {
                console.error(e);
                setError("Sonia couldn't prepare your digest right now. Please try again later.");
                // Fallback content
                setDigest({
                    greeting: "Bon jour! I had a little trouble connecting, but let's get your day started.",
                    topQuests: questItems.slice(0, 3).map(q => ({ text: q.text })),
                    appointments: [],
                    quote: "The secret of getting ahead is getting started."
                });
            } finally {
                setIsLoading(false);
            }
        };

        generateDigest();
    }, [questItems, timeBlocks]);
    
    const renderContent = () => {
        if (isLoading) {
            return (
                <div className="flex flex-col items-center">
                    <div className="w-8 h-8 border-4 border-slate-300 border-t-slate-600 rounded-full animate-spin mb-4"></div>
                    <p className="text-slate-600 font-semibold">Sonia is preparing your daily digest...</p>
                </div>
            );
        }

        if (error && !digest) {
            return <p className="text-red-600 text-center font-semibold">{error}</p>;
        }

        if (digest) {
            return (
                <div className="animate-fade-in text-left w-full">
                    <p className="text-lg text-slate-700 leading-relaxed mb-6">{digest.greeting}</p>
                    
                    {digest.topQuests.length > 0 && (
                        <div className="mb-6">
                            <h3 className="font-bold text-slate-800 font-serif text-xl border-b-2 border-slate-300 pb-2 mb-3">Top Quests for Today</h3>
                            <ul className="list-disc list-inside space-y-2 text-slate-700">
                                {digest.topQuests.map((quest, i) => <li key={i}>{quest.text}</li>)}
                            </ul>
                        </div>
                    )}

                    {digest.appointments.length > 0 && (
                        <div className="mb-6">
                            <h3 className="font-bold text-slate-800 font-serif text-xl border-b-2 border-slate-300 pb-2 mb-3">Upcoming Appointments</h3>
                            <ul className="list-disc list-inside space-y-2 text-slate-700">
                                 {digest.appointments.map((appt, i) => <li key={i}>{appt.text}</li>)}
                            </ul>
                        </div>
                    )}
                    
                    <div className="mt-6 pt-4 border-t border-slate-300/70 text-center">
                         <p className="text-slate-600 italic font-serif">"{digest.quote}"</p>
                    </div>
                </div>
            )
        }
        return null;
    };


    return (
         <div className="fixed inset-0 bg-slate-900/40 z-50 flex items-center justify-center p-4 backdrop-blur-lg animate-fade-in">
            <div className="relative bg-white/80 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-2xl p-8 transform transition-all animate-fade-in-up flex flex-col items-center">
                <div className="w-24 h-24 sm:w-32 sm:h-32 rounded-full bg-sky-400 p-2 flex-shrink-0 shadow-lg mb-4">
                    <SoniaAvatar />
                </div>
                <h2 className="text-3xl font-bold text-slate-800 font-serif mb-6">Your Daily Digest</h2>
                
                <div className="w-full min-h-[200px] flex items-center justify-center">
                    {renderContent()}
                </div>

                <button 
                    onClick={onClose}
                    disabled={isLoading}
                    className="mt-8 px-8 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md transition-colors disabled:opacity-50"
                >
                    {isLoading ? "Loading..." : "Let's Go!"}
                </button>
            </div>
        </div>
    );
};
import React, { useState, useEffect } from 'react';

export const DayProgressBar: React.FC = () => {
    const [progress, setProgress] = useState(0);
    const [currentTime, setCurrentTime] = useState('');

    const calculateProgress = () => {
        const now = new Date();
        const start = new Date(now);
        start.setHours(0, 0, 0, 0); // Start of the day (midnight)
        
        const totalMsInDay = 24 * 60 * 60 * 1000;
        const elapsedMs = now.getTime() - start.getTime();
        
        setProgress((elapsedMs / totalMsInDay) * 100);
        setCurrentTime(now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
    };

    useEffect(() => {
        calculateProgress();
        const interval = setInterval(calculateProgress, 60000); // Update every minute
        return () => clearInterval(interval);
    }, []);

    return (
        <div className="w-full max-w-2xl mx-auto px-4 group">
            <div 
                className="relative h-2 bg-slate-700/50 rounded-full overflow-hidden shadow-inner"
                title={`Time passed today: ${Math.round(progress)}%`}
            >
                <div 
                    className="absolute top-0 left-0 h-full bg-sky-400 rounded-full transition-all duration-1000 ease-linear"
                    style={{ width: `${progress}%` }}
                />
                <div 
                    className="absolute top-1/2 -translate-y-1/2 h-4 w-1 bg-white/90 shadow-lg rounded transition-all duration-300 opacity-0 group-hover:opacity-100"
                    style={{ left: `calc(${progress}% - 2px)` }}
                >
                    <span className="absolute bottom-full mb-2 left-1/2 -translate-x-1/2 text-xs font-semibold text-white bg-slate-800/70 px-2 py-0.5 rounded-md backdrop-blur-sm opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap">
                        {currentTime}
                    </span>
                </div>
            </div>
        </div>
    );
};
import React, { useState } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import { ExtractedItem } from '../hooks/types';

interface DigestProcessorProps {
    onBulkAddItems: (items: ExtractedItem[]) => void;
}

export const DigestProcessor: React.FC<DigestProcessorProps> = ({ onBulkAddItems }) => {
    const [isExpanded, setIsExpanded] = useState(false);
    const [digestText, setDigestText] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [extractedItems, setExtractedItems] = useState<ExtractedItem[] | null>(null);
    const [selectedItems, setSelectedItems] = useState<Record<string, boolean>>({});

    const handleProcess = async () => {
        if (!digestText.trim()) return;
        setIsLoading(true);
        setError(null);
        setExtractedItems(null);
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const response = await ai.models.generateContent({
                model: "gemini-2.5-flash",
                contents: `You are Sonia, a hyper-competent Chief of Staff. Analyze the following pasted text from a user's daily digest or notes. Extract all distinct thoughts, ideas, or to-do items. For each item, classify it as either a simple 'inbox' capture or a more concrete 'quest'.
                
                Pasted Text:
                "${digestText}"`,
                config: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: Type.ARRAY,
                        items: {
                            type: Type.OBJECT,
                            properties: {
                                text: { type: Type.STRING, description: "The text of the captured item." },
                                type: { type: Type.STRING, description: "The type of item.", enum: ["inbox", "quest"] }
                            },
                            required: ["text", "type"]
                        },
                    },
                },
            });

            const parsedItems = JSON.parse(response.text) as ExtractedItem[];
            setExtractedItems(parsedItems);
            setSelectedItems(parsedItems.reduce((acc, _, index) => ({ ...acc, [`${index}`]: true }), {}));
        } catch (e) {
            console.error(e);
            setError("Sonia had trouble processing that. Could you check the formatting and try again?");
        } finally {
            setIsLoading(false);
        }
    };
    
    const handleConfirm = () => {
        if (!extractedItems) return;
        const itemsToAdd = extractedItems.filter((_, index) => selectedItems[`${index}`]);
        onBulkAddItems(itemsToAdd);
        // Reset state after confirmation
        setDigestText('');
        setExtractedItems(null);
        setSelectedItems({});
        setIsExpanded(false);
    };

    if (!isExpanded) {
        return (
             <button onClick={() => setIsExpanded(true)} className="w-full text-left p-3 bg-white/60 rounded-lg shadow-sm hover:bg-white/80 font-semibold text-slate-700 flex items-center gap-3">
                <span className="text-xl">üìã</span>
                <span>Process External Digest</span>
            </button>
        )
    }

    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center justify-between gap-3 mb-2">
                <div className="flex items-center gap-3">
                    <span className="text-3xl" aria-hidden="true">üìã</span>
                    <h2 className="text-2xl font-bold text-slate-700 font-serif">Process Digest</h2>
                </div>
                <button onClick={() => setIsExpanded(false)} className="text-slate-500 hover:text-slate-800">&times;</button>
            </div>
            <p className="text-slate-600 mb-4 text-sm">Paste text from an email, notes, or anywhere else to turn it into actions.</p>
            
            {!extractedItems ? (
                 <>
                    <textarea 
                        value={digestText}
                        onChange={e => setDigestText(e.target.value)}
                        rows={6}
                        placeholder="Paste your daily digest or notes here..."
                        className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner"
                    />
                    <button onClick={handleProcess} disabled={isLoading || !digestText.trim()} className="mt-2 w-full px-6 py-2 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-800 disabled:opacity-50 transition-colors">
                        {isLoading ? "Processing..." : "Process with Sonia"}
                    </button>
                    {error && <p className="text-red-500 text-sm mt-2 text-center">{error}</p>}
                </>
            ) : (
                <>
                    <h3 className="font-semibold text-slate-700 mb-2">Sonia's suggestions:</h3>
                    <div className="max-h-60 overflow-y-auto custom-scrollbar pr-2 space-y-2 text-left">
                        {extractedItems.map((item, index) => (
                            <div key={index} className="flex items-center p-2 bg-white/60 rounded-md">
                                <input type="checkbox" id={`proc-item-${index}`} checked={selectedItems[`${index}`] || false} onChange={() => setSelectedItems(prev => ({...prev, [`${index}`]: !prev[`${index}`]}))} className="w-5 h-5 rounded text-indigo-500 mr-3" />
                                <label htmlFor={`proc-item-${index}`} className="flex-grow text-slate-800">{item.text}</label>
                                <span className={`text-xs font-semibold px-2 py-0.5 rounded-full ${item.type === 'quest' ? 'bg-slate-300 text-slate-800' : 'bg-slate-200 text-slate-700'}`}>{item.type}</span>
                            </div>
                        ))}
                    </div>
                     <button onClick={handleConfirm} className="mt-4 w-full px-8 py-3 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold rounded-lg shadow-md transition-colors">Confirm and Add</button>
                </>
            )}
        </div>
    );
};
import React, { useState } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CharacterData } from '../hooks/types';

interface EmotionalBarometerProps {
    character: CharacterData;
}

type EmotionalState = 'Focus' | 'Frustration' | 'Energy';

export const EmotionalBarometer: React.FC<EmotionalBarometerProps> = ({ character }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [menu, setMenu] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);

    const handleLogState = async (state: EmotionalState) => {
        setIsLoading(true);
        setMenu(null);
        setError(null);

        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const prompt = `You are ${character.name}, a calm, reflective, and empathetic guide. The user has just logged their current emotional state as "${state}". 
            Provide a "Co-Regulation Menu" of 3 simple, actionable interventions to help them manage this feeling. Frame it with kindness and encouragement. 
            Format the response as a simple list with each item on a new line, prefixed with a hyphen. Do not add any intro, outro, or other commentary.`;

            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: prompt,
            });
            
            setMenu(response.text);

        } catch (e) {
            console.error(e);
            setError('Could not generate suggestions at this time.');
        } finally {
            setIsLoading(false);
        }
    };

    const states: { name: EmotionalState, emoji: string, color: string, style: string }[] = [
        { name: 'Focus', emoji: 'üéØ', color: 'sky', style: 'bg-sky-200/60 border-sky-300/50 hover:bg-sky-300/80 text-sky-800'},
        { name: 'Frustration', emoji: 'üò§', color: 'rose', style: 'bg-rose-200/60 border-rose-300/50 hover:bg-rose-300/80 text-rose-800'},
        { name: 'Energy', emoji: '‚ö°Ô∏è', color: 'amber', style: 'bg-amber-200/60 border-amber-300/50 hover:bg-amber-300/80 text-amber-800'}
    ];

    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center gap-3 mb-4">
                <span className="text-3xl" aria-hidden="true">üå°Ô∏è</span>
                <h2 className="text-2xl font-bold text-slate-700 font-serif">Emotional Barometer</h2>
            </div>
            <p className="text-slate-600 mb-4 text-sm">Check in with yourself. How are you feeling right now?</p>

            <div className="grid grid-cols-3 gap-4 mb-4">
                {states.map(({ name, emoji, style }) => (
                    <button
                        key={name}
                        onClick={() => handleLogState(name)}
                        disabled={isLoading}
                        className={`p-4 rounded-lg border text-center transition-colors disabled:opacity-50 ${style}`}
                    >
                        <span className="text-4xl">{emoji}</span>
                        <p className={`font-semibold text-lg mt-2`}>{name}</p>
                    </button>
                ))}
            </div>

            {isLoading && <p className="text-center text-slate-600 font-medium mt-4">Sister Mary is preparing some thoughts for you...</p>}
            {error && <p className="text-red-500 text-center font-medium mt-4">{error}</p>}
            
            {menu && (
                <div className="mt-4 p-4 bg-stone-100/50 rounded-lg border border-stone-200/50 animate-fade-in">
                    <h3 className="font-semibold text-slate-700 mb-2">Sister Mary's Suggestions for You:</h3>
                    <ul className="list-disc list-inside text-slate-800 space-y-1">
                        {menu.split('\n').map((item, index) => (
                           item.trim().length > 0 && <li key={index}>{item.trim().replace(/^- /, '')}</li>
                        ))}
                    </ul>
                </div>
            )}
        </div>
    );
};
import React, { useState, useEffect, useRef, forwardRef, useImperativeHandle } from 'react';
import { GoogleGenAI, FunctionDeclaration, Type, Modality, Blob, LiveServerMessage } from '@google/genai';
import { HubId } from '../hooks/types';

// A local interface to represent the LiveSession object, as it's not exported from the library.
interface LiveSession {
  sendRealtimeInput(input: { media: Blob }): void;
  sendToolResponse(response: { functionResponses: { id: string; name: string; response: { result: string; } } }): void;
  close(): void;
}

// From docs - audio helpers
function encode(bytes: Uint8Array) {
  let binary = '';
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

function decode(base64: string) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

async function decodeAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number,
  numChannels: number,
): Promise<AudioBuffer> {
  const dataInt16 = new Int16Array(data.buffer);
  const frameCount = dataInt16.length / numChannels;
  const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < frameCount; i++) {
      channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
    }
  }
  return buffer;
}


function createBlob(data: Float32Array): Blob {
  const l = data.length;
  const int16 = new Int16Array(l);
  for (let i = 0; i < l; i++) {
    int16[i] = data[i] * 32768;
  }
  return {
    data: encode(new Uint8Array(int16.buffer)),
    mimeType: 'audio/pcm;rate=16000',
  };
}

interface GlobalVoiceControlProps {
    onCapture: (text: string) => void;
    onOpenHub: (id: HubId) => void;
    onCloseHub: () => void;
    onAddQuest: (text: string) => void;
    onSparkJoy: () => void;
    onToggleSanctuaryMode: () => void;
    onStartHuddle: () => void;
}

export interface GlobalVoiceControlHandle {
  startListening: () => void;
  stopListening: () => void;
}

const functionDeclarations: FunctionDeclaration[] = [
    {
        name: 'capture',
        parameters: {
            type: Type.OBJECT,
            description: 'Captures a thought, idea, or to-do item into the user\'s inbox.',
            properties: {
                item: {
                    type: Type.STRING,
                    description: 'The content of the item to capture. For example, "buy milk" or "new idea for the marketing campaign".',
                },
            },
            required: ['item'],
        },
    },
    {
        name: 'openHub',
        parameters: {
            type: Type.OBJECT,
            description: 'Opens the view for a specific character or "hub".',
            properties: {
                characterName: {
                    type: Type.STRING,
                    description: 'The name of the character hub to open. Can be "Sonia", "Pep", "Sister Mary", "Fi-Nancy", or "Jake".',
                },
            },
            required: ['characterName'],
        },
    },
    {
        name: 'closeHub',
        parameters: {
            type: Type.OBJECT,
            description: 'Closes the current character hub view and returns to the main lounge screen.',
            properties: {},
        },
    },
    {
        name: 'addQuest',
        parameters: {
            type: Type.OBJECT,
            description: 'Adds a new quest directly to the user\'s quest log.',
            properties: {
                quest: {
                    type: Type.STRING,
                    description: 'The content of the quest to add. For example, "finish the project proposal".',
                },
            },
            required: ['quest'],
        },
    },
    {
        name: 'sparkJoy',
        parameters: {
            type: Type.OBJECT,
            description: 'Triggers a delightful, brief celebration animation.',
            properties: {},
        },
    },
    {
        name: 'toggleSanctuaryMode',
        parameters: {
            type: Type.OBJECT,
            description: 'Toggles Sanctuary Mode on or off to provide a calmer, monochrome interface.',
            properties: {},
        },
    },
    {
        name: 'startHuddle',
        parameters: {
            type: Type.OBJECT,
            description: 'Initiates a "Team Huddle" with Sonia and Sister Mary Samuel for a quick piece of strategic advice.',
            properties: {},
        },
    },
];

export const GlobalVoiceControl = forwardRef<GlobalVoiceControlHandle, GlobalVoiceControlProps>((props, ref) => {
    const { onCapture, onOpenHub, onCloseHub, onAddQuest, onSparkJoy, onToggleSanctuaryMode, onStartHuddle } = props;
    const [isListening, setIsListening] = useState(false);
    const [isAvailable, setIsAvailable] = useState(false);
    
    const sessionPromiseRef = useRef<Promise<LiveSession> | null>(null);
    const inputAudioContextRef = useRef<AudioContext | null>(null);
    const outputAudioContextRef = useRef<AudioContext | null>(null);
    const mediaStreamSourceRef = useRef<MediaStreamAudioSourceNode | null>(null);
    const scriptProcessorRef = useRef<ScriptProcessorNode | null>(null);
    const nextStartTimeRef = useRef<number>(0);
    const audioSourcesRef = useRef<Set<AudioBufferSourceNode>>(new Set());
    
    useEffect(() => {
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            setIsAvailable(true);
        }

        return () => {
            stopListening();
        };
    }, []);

    const startListening = async () => {
        if (isListening || !process.env.API_KEY) {
            if (!process.env.API_KEY) console.error("API_KEY environment variable not set.");
            return;
        }

        setIsListening(true);
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            sessionPromiseRef.current = ai.live.connect({
                model: 'gemini-2.5-flash-native-audio-preview-09-2025',
                callbacks: {
                    onopen: () => {
                        console.log('Global voice session opened.');
                        inputAudioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: 16000 });
                        outputAudioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: 24000 });
                        
                        mediaStreamSourceRef.current = inputAudioContextRef.current.createMediaStreamSource(stream);
                        scriptProcessorRef.current = inputAudioContextRef.current.createScriptProcessor(4096, 1, 1);

                        scriptProcessorRef.current.onaudioprocess = (audioProcessingEvent) => {
                            const inputData = audioProcessingEvent.inputBuffer.getChannelData(0);
                            const pcmBlob = createBlob(inputData);
                            sessionPromiseRef.current?.then((session) => {
                                session.sendRealtimeInput({ media: pcmBlob });
                            });
                        };
                        mediaStreamSourceRef.current.connect(scriptProcessorRef.current);
                        scriptProcessorRef.current.connect(inputAudioContextRef.current.destination);
                    },
                    onmessage: async (message: LiveServerMessage) => {
                        if (message.toolCall) {
                            for (const fc of message.toolCall.functionCalls) {
                                let result = "ok";
                                switch (fc.name) {
                                    case 'capture': onCapture(fc.args.item as string); break;
                                    case 'addQuest': onAddQuest(fc.args.quest as string); break;
                                    case 'closeHub': onCloseHub(); break;
                                    case 'sparkJoy': onSparkJoy(); break;
                                    case 'toggleSanctuaryMode': onToggleSanctuaryMode(); break;
                                    case 'startHuddle': onStartHuddle(); break;
                                    case 'openHub':
                                        const hubId = ((fc.args.characterName as string).toLowerCase().replace(/[\s-]/g, '') as HubId);
                                        const matchedId = Object.values(HubId).find(id => id.replace('-', '') === hubId);
                                        if (matchedId) {
                                            onOpenHub(matchedId);
                                        } else {
                                            result = `Unknown character: ${fc.args.characterName}`;
                                        }
                                        break;
                                    default: result = `Unknown function: ${fc.name}`;
                                }
                                sessionPromiseRef.current?.then((session) => {
                                    session.sendToolResponse({
                                        functionResponses: { id: fc.id, name: fc.name, response: { result } }
                                    });
                                });
                            }
                        }
                        const base64EncodedAudioString = message.serverContent?.modelTurn?.parts[0]?.inlineData.data;
                        if (base64EncodedAudioString && outputAudioContextRef.current) {
                            nextStartTimeRef.current = Math.max(nextStartTimeRef.current, outputAudioContextRef.current.currentTime);
                            const audioBuffer = await decodeAudioData(decode(base64EncodedAudioString), outputAudioContextRef.current, 24000, 1);
                            const source = outputAudioContextRef.current.createBufferSource();
                            source.buffer = audioBuffer;
                            source.connect(outputAudioContextRef.current.destination);
                            source.addEventListener('ended', () => audioSourcesRef.current.delete(source));
                            source.start(nextStartTimeRef.current);
                            nextStartTimeRef.current += audioBuffer.duration;
                            audioSourcesRef.current.add(source);
                        }
                    },
                    onerror: (e: ErrorEvent) => {
                        console.error('Global voice session error:', e);
                        stopListening();
                    },
                    onclose: (e: CloseEvent) => {
                        console.log('Global voice session closed.');
                    },
                },
                config: {
                    responseModalities: [Modality.AUDIO],
                    tools: [{ functionDeclarations }],
                    systemInstruction: 'You are a voice assistant for a productivity app called "The Hub". The user will give you commands to manage their tasks. Call the appropriate functions. If the user asks to "call a huddle" or "start a huddle", use the startHuddle function. If the user simply says the name of a character (Sonia, Pep, Sister Mary, Fi-Nancy, or Jake), treat it as a command to open that character\'s hub using the `openHub` function. Confirm actions with short, friendly phrases like "Got it." or "Opening Sonia\'s hub for you."',
                },
            });

            sessionPromiseRef.current.catch(err => {
                console.error("Session promise rejected:", err);
                stopListening();
            });

        } catch (err) {
            console.error('Error starting voice session:', err);
            alert("Could not access microphone. Please check permissions.");
            setIsListening(false);
        }
    };

    const stopListening = () => {
        if (!isListening) return;

        sessionPromiseRef.current?.then(session => session.close()).catch(console.error);
        
        scriptProcessorRef.current?.disconnect();
        mediaStreamSourceRef.current?.disconnect();
        inputAudioContextRef.current?.close().catch(console.error);
        outputAudioContextRef.current?.close().catch(console.error);

        for (const source of audioSourcesRef.current.values()) {
          source.stop();
        }
        audioSourcesRef.current.clear();

        sessionPromiseRef.current = null;
        scriptProcessorRef.current = null;
        mediaStreamSourceRef.current = null;
        inputAudioContextRef.current = null;
        outputAudioContextRef.current = null;
        nextStartTimeRef.current = 0;

        setIsListening(false);
    };
    
    useImperativeHandle(ref, () => ({
        startListening,
        stopListening,
    }));

    const handleToggleListening = () => {
        if (isListening) {
            stopListening();
        } else {
            startListening();
        }
    };
    
    if (!isAvailable) return null;

    return (
        <div className="fixed bottom-8 left-8 z-30">
            <button
                onClick={handleToggleListening}
                className={`w-16 h-16 rounded-full text-white shadow-lg flex items-center justify-center transform hover:scale-110 transition-all duration-300 bg-slate-800 hover:bg-slate-700 ${isListening ? 'animate-pulse' : ''}`}
                aria-label={isListening ? "Stop voice control" : "Start voice control"}
                title={isListening ? "Stop voice control" : "Start voice control"}
            >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" viewBox="0 0 20 20" fill="currentColor">
                    {isListening ? (
                         <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                    ) : (
                        <>
                            <path d="M7 4a3 3 0 016 0v6a3 3 0 11-6 0V4z" />
                            <path d="M5.5 10.5a.5.5 0 01.5.5v1a4 4 0 004 4h0a4 4 0 004-4v-1a.5.5 0 011 0v1a5 5 0 01-4.5 4.975V19h2a.5.5 0 010 1h-5a.5.5 0 010-1h2v-1.525A5 5 0 014.5 12v-1a.5.5 0 01.5-.5z" />
                        </>
                    )}
                </svg>
            </button>
        </div>
    );
});
import React from 'react';
import { TimeOfDay } from '../hooks/types';

export const HubContainer: React.FC<{ children: React.ReactNode; timeOfDay: TimeOfDay; }> = ({ children, timeOfDay }) => {
    
    const skyFill = {
        day: 'rgba(135, 206, 235, 0.7)', // Light Sky Blue
        dusk: 'rgba(70, 130, 180, 0.7)',  // Steel Blue
        night: 'rgba(12, 20, 69, 0.9)',    // Dark Navy
    }[timeOfDay];

    const godRaysFill = {
        day: 'rgba(255, 253, 240, 0.3)', // Soft daylight
        dusk: 'rgba(255, 165, 0, 0.2)',  // Warm orange dusk
        night: 'rgba(200, 220, 255, 0.1)' // Cool moonlight
    }[timeOfDay];
    
    const starsOpacity = timeOfDay === 'night' ? 1 : 0;

    return (
        <main className="relative min-h-screen w-full overflow-hidden bg-[#EAE3D9]">
            <svg
                width="100%"
                height="100%"
                viewBox="0 0 800 600"
                preserveAspectRatio="xMidYMid slice"
                className="absolute inset-0 w-full h-full object-cover -z-10"
            >
                {/* Base color */}
                <rect width="800" height="600" fill="#EAE3D9" />

                {/* Sky and Trees outside window */}
                <g id="window-view" style={{ transition: 'all 1s ease-in-out' }}>
                    <path d="M 450 100 A 150 150 0 0 1 750 100 L 750 450 L 450 450 Z" fill={skyFill} />
                    <circle cx="530" cy="480" r="100" fill="rgba(60, 179, 113, 0.6)" />
                    <circle cx="680" cy="460" r="120" fill="rgba(46, 139, 87, 0.6)" />
                     <g id="Stars" opacity={starsOpacity} style={{ transition: 'opacity 1s ease-in-out' }}>
                        <circle fill="#FFFFFF" cx="550" cy="200" r="1.5" />
                        <circle fill="#FFFFFF" cx="650" cy="180" r="1" />
                        <circle fill="#FFFFFF" cx="700" cy="250" r="2" />
                        <circle fill="#FFFFFF" cx="600" cy="300" r="1.2" />
                    </g>
                </g>

                {/* Room Structure (lines) */}
                <g id="room-lines" stroke="#4D443E" strokeWidth="2" fill="none">
                    {/* Floor */}
                    <path d="M 0 550 L 800 550" />
                    <path d="M 0 520 L 800 520" />
                    <path d="M 0 490 L 800 490" />
                    <path d="M 0 460 L 800 460" />
                     {/* Back wall */}
                    <path d="M 0 430 L 800 430" />
                    {/* Window */}
                    <path d="M 450 100 A 150 150 0 0 1 750 100 L 750 450 L 450 450 Z" />
                    <line x1="600" y1="100" x2="600" y2="450" />
                    <line x1="450" y1="275" x2="750" y2="275" />
                    {/* Whiteboard */}
                    <rect x="100" y="200" width="250" height="150" />
                    <line x1="100" y1="380" x2="350" y2="380" />
                </g>
                
                 {/* God Rays */}
                <g id="lighting" style={{ transition: 'fill 1s ease-in-out' }} fill={godRaysFill}>
                    <polygon points="450 100, 300 550, 400 550" />
                    <polygon points="525 100, 425 550, 500 550" />
                    <polygon points="675 100, 625 550, 700 550" />
                </g>

                 {/* Text on whiteboard */}
                <text x="225" y="280" fontFamily="Caveat, cursive" fontSize="40" fill="#4D443E" textAnchor="middle">
                    AGENDA
                </text>
            </svg>
            <div className="relative z-10">
                {children}
            </div>
        </main>
    );
};
import React, { useState, useCallback } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import { CharacterData, HubId, CapturedItem, IdeaNode, ExtractedItem } from '../hooks/types';
import { VoiceChatInterface } from './VoiceChatInterface';
import { AvatarCustomizer } from './AvatarCustomizer';

// Character-specific Widgets
import { OmniInbox } from './OmniInbox';
import { QuestLog } from './QuestLog';
import { WeeklyReview } from './WeeklyReview';
import { ValuesPrioritization } from './ValuesPrioritization';
import { ProjectBriefs } from './ProjectBriefs';
import { TrophyRoom } from './TrophyRoom';
import { SundaySermonette } from './SundaySermonette';
import { EmotionalBarometer } from './EmotionalBarometer';
import { CommitmentContract } from './CommitmentContract';
import { BodyDoubleRoom } from './BodyDoubleRoom';
import { ProcrastinationIntervention } from './ProcrastinationIntervention';
import { IdeaGreenhouse } from './IdeaGreenhouse';
import { SomedayMaybeSafari } from './SomedayMaybeSafari';
import { StrategicSinter } from './StrategicSinter';
import { ProactiveTriage } from './ProactiveTriage';
import { DigestProcessor } from './DigestProcessor';

interface HubViewProps {
    character: CharacterData;
    allCharacters: CharacterData[];
    onBack: () => void;
    inboxItems: CapturedItem[];
    questItems: CapturedItem[];
    completedQuests: CapturedItem[];
    onAvatarSave: (hubId: HubId, newAvatarUrl: string) => void;
    procrastinationAlert: CapturedItem | null;
    onClearProcrastinationAlert: () => void;
    userValues: string[];
    onSetUserValues: (values: string[]) => void;
    onDeleteItem: (itemId: string) => void;
    onPromoteToQuest: (itemId: string) => void;
    onAddQuest: (text: string) => void;
    onBulkAddItems: (items: ExtractedItem[]) => void;
    onCompleteQuest: (itemId: string) => void;
    onPostponeQuest: (itemId: string) => void;
    onStartBossBattle: (item: CapturedItem) => void;
    ideaNodes: IdeaNode[];
    setIdeaNodes: React.Dispatch<React.SetStateAction<IdeaNode[]>>;
    onStartHuddle: () => void;
}

export const HubView: React.FC<HubViewProps> = ({ 
    character, 
    allCharacters, 
    onBack,
    inboxItems,
    questItems,
    completedQuests,
    onAvatarSave,
    procrastinationAlert,
    onClearProcrastinationAlert,
    userValues,
    onSetUserValues,
    onDeleteItem,
    onPromoteToQuest,
    onAddQuest,
    onBulkAddItems,
    onCompleteQuest,
    onPostponeQuest,
    onStartBossBattle,
    ideaNodes,
    setIdeaNodes,
    onStartHuddle
}) => {
    const [isCustomizing, setIsCustomizing] = useState(false);
    const [showWeeklyReview, setShowWeeklyReview] = useState(false);
    const [showBodyDouble, setShowBodyDouble] = useState(false);
    const [isHuddleActive, setIsHuddleActive] = useState(false);
    const [jakeView, setJakeView] = useState<'default' | 'greenhouse' | 'safari'>('default');
    
    // State for QuestLog Focus Mode
    const [isFocusMode, setIsFocusMode] = useState(false);
    const [focusQuestId, setFocusQuestId] = useState<string | null>(null);
    const [isFocusLoading, setIsFocusLoading] = useState(false);
    const [focusError, setFocusError] = useState<string | null>(null);

    const handleToggleFocusMode = useCallback(async (enabled: boolean) => {
        setIsFocusMode(enabled);
        setFocusQuestId(null);
        setFocusError(null);
        if (enabled && questItems.length > 0) {
            setIsFocusLoading(true);
            try {
                const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
                const response = await ai.models.generateContent({
                    model: "gemini-2.5-flash",
                    contents: `You are Sonia, a hyper-competent Chief of Staff. Based on the user's core values and their current quest log, identify the single most important quest to focus on to create momentum and clarity.
                
                    Core Values:
                    ${userValues.join(', ') || 'Not defined. Focus on a task that seems foundational or unblocks others.'}

                    Quest Log (JSON format with IDs):
                    ${JSON.stringify(questItems.map(q => ({id: q.id, text: q.text})))}

                    Respond with a JSON object containing the ID of the most important quest.`,
                    config: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: Type.OBJECT,
                            properties: {
                                id: { type: Type.STRING, description: "The ID of the most important quest from the provided list." }
                            },
                            required: ["id"]
                        },
                    },
                });
                
                const result = JSON.parse(response.text);

                if (result.id && questItems.some(q => q.id === result.id)) {
                     setFocusQuestId(result.id);
                } else {
                    setFocusQuestId(questItems[0].id);
                    console.warn("AI returned an invalid quest ID, falling back to the first quest.");
                }

            } catch (e) {
                console.error(e);
                setFocusError("Sonia is having trouble focusing right now. Please try again.");
                setIsFocusMode(false);
            } finally {
                setIsFocusLoading(false);
            }
        }
    }, [questItems, userValues]);

    const AvatarComponent = character.avatar;
    
    const renderWidgets = () => {
        switch (character.id) {
            case HubId.Sonia:
                return (
                    <div className="space-y-4">
                        <div className="p-1 bg-black/10 rounded-xl">
                            <div className="space-y-4">
                                <OmniInbox 
                                    items={inboxItems} 
                                    onDeleteItem={onDeleteItem} 
                                    onPromoteToQuest={onPromoteToQuest} 
                                    onAddQuest={onAddQuest} 
                                />
                                <QuestLog 
                                    items={questItems} 
                                    onCompleteQuest={onCompleteQuest} 
                                    onStartBossBattle={onStartBossBattle} 
                                    onPostponeQuest={onPostponeQuest}
                                    isFocusMode={isFocusMode}
                                    onToggleFocusMode={handleToggleFocusMode}
                                    focusQuestId={focusQuestId}
                                    isFocusLoading={isFocusLoading}
                                    focusError={focusError}
                                />
                            </div>
                        </div>
                        <DigestProcessor onBulkAddItems={onBulkAddItems} />
                        <ProactiveTriage onAddQuest={onAddQuest} />
                        <button onClick={onStartHuddle} className="w-full text-center p-3 bg-white/60 rounded-lg shadow-sm hover:bg-white/80 font-semibold text-slate-700">Call Team Huddle</button>
                        <button onClick={() => setIsHuddleActive(true)} className="w-full text-center p-3 bg-white/60 rounded-lg shadow-sm hover:bg-white/80 font-semibold text-slate-700">Start Strategic Sinter</button>
                        <button onClick={() => setShowWeeklyReview(true)} className="w-full text-center p-3 bg-white/60 rounded-lg shadow-sm hover:bg-white/80 font-semibold text-slate-700">Start Weekly Review</button>
                        {isHuddleActive && <StrategicSinter onFinish={() => setIsHuddleActive(false)} onBulkAddItems={onBulkAddItems} characters={allCharacters} />}
                        {showWeeklyReview && <WeeklyReview onFinish={() => setShowWeeklyReview(false)} />}
                        <ValuesPrioritization userValues={userValues} onSetUserValues={onSetUserValues} questItems={questItems} />
                        <ProjectBriefs questItems={questItems} inboxItems={inboxItems} completedQuests={completedQuests} characters={allCharacters} />
                    </div>
                );
            case HubId.Pep:
                return <TrophyRoom completedQuests={completedQuests} character={character} />;
            case HubId.SisterMary:
                 return (
                    <div className="space-y-4">
                        {procrastinationAlert && <ProcrastinationIntervention quest={procrastinationAlert} onAcknowledge={onClearProcrastinationAlert} character={character}/>}
                        <SundaySermonette character={character} completedQuests={completedQuests} />
                        <EmotionalBarometer character={character} />
                    </div>
                );
            case HubId.FiNancy:
                 return <CommitmentContract />;
            case HubId.Jake:
                return (
                     <div className="space-y-4">
                        <button onClick={() => setJakeView('greenhouse')} className="w-full text-center p-3 bg-white/60 rounded-lg shadow-sm hover:bg-white/80 font-semibold text-slate-700">Enter Idea Greenhouse</button>
                        <button onClick={() => setJakeView('safari')} className="w-full text-center p-3 bg-white/60 rounded-lg shadow-sm hover:bg-white/80 font-semibold text-slate-700">Go on a Someday/Maybe Safari</button>
                        <button onClick={() => setShowBodyDouble(true)} className="w-full text-center p-3 bg-white/60 rounded-lg shadow-sm hover:bg-white/80 font-semibold text-slate-700">Enter Body Double Room</button>
                        {showBodyDouble && <BodyDoubleRoom onClose={() => setShowBodyDouble(false)} />}
                    </div>
                );
            default:
                return null;
        }
    };
    
    return (
        <div className="min-h-screen flex flex-col items-center p-4 pt-16 sm:p-8 animate-fade-in">
            <button onClick={onBack} className="absolute top-4 left-4 flex items-center gap-2 text-white/80 hover:text-white font-semibold z-20">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" /></svg>
                Back to Lounge
            </button>
            
            <div className="flex flex-col md:flex-row gap-8 w-full max-w-6xl">
                <div className="md:w-1/3 flex-shrink-0 flex flex-col items-center">
                    <div className="relative group">
                        <div className="w-40 h-40 rounded-full p-2 bg-white/50 shadow-lg">
                             {typeof AvatarComponent === 'string' 
                                ? <img src={AvatarComponent} alt={character.name} className="w-full h-full object-cover rounded-full" />
                                : <AvatarComponent className="w-full h-full" />
                            }
                        </div>
                         <button onClick={() => setIsCustomizing(true)} className="absolute inset-0 bg-black/50 rounded-full flex items-center justify-center text-white opacity-0 group-hover:opacity-100 transition-opacity">Customize</button>
                    </div>
                    <h2 className="text-3xl font-bold text-white mt-4 font-serif">{character.name}</h2>
                    <p className="text-white/80">{character.title}</p>
                    <div className="mt-6 w-full max-w-sm">
                        {renderWidgets()}
                    </div>
                </div>

                <div className="md:w-2/3 flex items-start justify-center">
                    {(() => {
                        if (character.id === HubId.Jake) {
                            switch (jakeView) {
                                case 'greenhouse':
                                    return <IdeaGreenhouse nodes={ideaNodes} setNodes={setIdeaNodes} onBack={() => setJakeView('default')} />;
                                case 'safari':
                                    return <SomedayMaybeSafari items={inboxItems} onPromoteToQuest={onPromoteToQuest} onDeleteItem={onDeleteItem} onBack={() => setJakeView('default')} />;
                                default:
                                    return <VoiceChatInterface character={character} onClose={onBack} />;
                            }
                        }
                        return <VoiceChatInterface character={character} onClose={onBack} />;
                    })()}
                </div>
            </div>
            
            {isCustomizing && (
                <AvatarCustomizer 
                    character={character} 
                    onClose={() => setIsCustomizing(false)} 
                    onSave={(newUrl) => {
                        onAvatarSave(character.id, newUrl);
                        setIsCustomizing(false);
                    }}
                />
            )}
            
        </div>
    );
};
import React, { useState, useRef, useCallback, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { IdeaNode } from '../hooks/types';

interface IdeaGreenhouseProps {
    nodes: IdeaNode[];
    setNodes: React.Dispatch<React.SetStateAction<IdeaNode[]>>;
    onBack: () => void;
}

export const IdeaGreenhouse: React.FC<IdeaGreenhouseProps> = ({ nodes, setNodes, onBack }) => {
    const [editingNode, setEditingNode] = useState<string | null>(null);
    const [draggingNode, setDraggingNode] = useState<{ id: string; offsetX: number; offsetY: number; } | null>(null);
    const canvasRef = useRef<HTMLDivElement>(null);

    const handleCanvasDoubleClick = (e: React.MouseEvent<HTMLDivElement>) => {
        if (editingNode || !canvasRef.current) return;
        const rect = canvasRef.current.getBoundingClientRect();
        const newNode: IdeaNode = {
            id: uuidv4(),
            text: 'New Idea',
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
        };
        setNodes([...nodes, newNode]);
        setEditingNode(newNode.id);
    };

    const handleNodeChange = (id: string, text: string) => {
        setNodes(nodes.map(node => node.id === id ? { ...node, text } : node));
    };

    const handleNodeBlur = () => {
        setEditingNode(null);
    };
    
    const handleNodeMouseDown = (e: React.MouseEvent, id: string) => {
        const node = nodes.find(n => n.id === id);
        const target = e.target as HTMLElement;
        const nodeElement = target.closest('.idea-node') as HTMLElement;
        if (!node || !nodeElement) return;

        const rect = nodeElement.getBoundingClientRect();
        setDraggingNode({
            id,
            offsetX: e.clientX - rect.left,
            offsetY: e.clientY - rect.top,
        });
    };

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (!draggingNode || !canvasRef.current) return;
        const rect = canvasRef.current.getBoundingClientRect();
        setNodes(prevNodes => prevNodes.map(node => 
            node.id === draggingNode.id 
            ? { ...node, x: e.clientX - rect.left - draggingNode.offsetX, y: e.clientY - rect.top - draggingNode.offsetY } 
            : node
        ));
    }, [draggingNode, setNodes]);

    const handleMouseUp = useCallback(() => {
        setDraggingNode(null);
    }, []);
    
    useEffect(() => {
        if (draggingNode) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [draggingNode, handleMouseMove, handleMouseUp]);


    return (
        <div className="w-full max-w-4xl h-[70vh] bg-stone-100/70 backdrop-blur-sm rounded-2xl shadow-lg border border-stone-200/50 font-sans flex flex-col animate-fade-in-up">
            <div className="flex items-center justify-between p-4 border-b border-stone-200/50">
                <div className="flex items-center gap-3">
                    <span className="text-3xl" aria-hidden="true">üå±</span>
                    <h2 className="text-2xl font-bold text-slate-700 font-serif">Idea Greenhouse</h2>
                </div>
                <button onClick={onBack} className="px-4 py-2 bg-slate-200/70 text-slate-800 font-semibold rounded-lg hover:bg-slate-300/80 transition-colors shadow-sm text-sm">Back to Hub</button>
            </div>
            <p className="text-slate-600 text-sm px-4 pt-2">A place for unstructured, visual brainstorming. Double-click to plant a new idea.</p>
            <div 
                ref={canvasRef}
                className="flex-grow relative overflow-auto custom-scrollbar m-4 rounded-lg bg-cover bg-center"
                style={{ backgroundImage: "url('https://www.transparenttextures.com/patterns/notebook-dark.png')" }}
                onDoubleClick={handleCanvasDoubleClick}
            >
                {nodes.map(node => (
                    <div
                        key={node.id}
                        className="idea-node absolute p-2 cursor-grab"
                        style={{ left: `${node.x}px`, top: `${node.y}px` }}
                        onMouseDown={(e) => handleNodeMouseDown(e, node.id)}
                        title="Drag to move, double-click text to edit"
                    >
                         <div className="w-48 h-24 p-4 bg-yellow-200 shadow-lg rounded-md border border-yellow-300 transform rotate-[-2deg] hover:rotate-0 hover:scale-105 transition-transform">
                            {editingNode === node.id ? (
                                <textarea
                                    value={node.text}
                                    onChange={(e) => handleNodeChange(node.id, e.target.value)}
                                    onBlur={handleNodeBlur}
                                    className="w-full h-full bg-transparent border-none focus:ring-0 resize-none font-serif"
                                    autoFocus
                                />
                            ) : (
                                <p onDoubleClick={(e) => { e.stopPropagation(); setEditingNode(node.id); }} className="w-full h-full font-serif whitespace-pre-wrap">
                                    {node.text}
                                </p>
                            )}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};
import React from 'react';
import { Character } from './Character';
import { CharacterData, HubId } from '../hooks/types';

interface LoungeProps {
    characters: CharacterData[];
    onSelectHub: (id: HubId) => void;
    isSanctuary: boolean;
    procrastinationAlertQuestId: string | null;
}

export const Lounge: React.FC<LoungeProps> = ({
    characters,
    onSelectHub,
    isSanctuary,
    procrastinationAlertQuestId
}) => {
    const sisterMary = characters.find(c => c.id === HubId.SisterMary);
    // Define a stable order for the other characters
    const otherCharacterOrder = [HubId.Sonia, HubId.Pep, HubId.FiNancy, HubId.Jake];
    const otherCharacters = characters
        .filter(c => c.id !== HubId.SisterMary)
        .sort((a, b) => otherCharacterOrder.indexOf(a.id) - otherCharacterOrder.indexOf(b.id));
    
    return (
        <div className="min-h-screen flex flex-col items-center justify-between p-4 pt-8 sm:pt-16 relative">
            <div className="text-center mb-8 sm:mb-12 z-10">
                <h1 className="text-6xl sm:text-7xl font-bold text-stone-100 font-lounge-title tracking-normal" style={{textShadow: '2px 2px 8px rgba(45, 55, 72, 0.6)'}}>the Lounge</h1>
                <p className="text-slate-800 mt-2 text-xl font-serif italic">Your sanctuary for focus and creativity.</p>
            </div>
            
            {/* New Grid Layout for Characters */}
            <div className="w-full max-w-sm flex-grow grid grid-rows-[auto_auto] grid-cols-2 gap-x-8 gap-y-4 items-center justify-items-center px-4 z-20 pb-32">
                 {/* Top Row: Sister Mary */}
                {sisterMary && (
                    <div className="col-span-2 flex justify-center items-center py-4">
                         <Character
                            key={sisterMary.id}
                            character={sisterMary}
                            onClick={() => onSelectHub(sisterMary.id)}
                            isSanctuary={isSanctuary}
                            hasProcrastinationAlert={procrastinationAlertQuestId !== null}
                        />
                    </div>
                )}
                
                {/* Bottom Rows: Other characters */}
                {otherCharacters.map(char => (
                    <Character
                        key={char.id}
                        character={char}
                        onClick={() => onSelectHub(char.id)}
                        isSanctuary={isSanctuary}
                    />
                ))}
            </div>
        </div>
    );
};
import React, { useState, useEffect } from 'react';

// Define the structure for a visual node
interface IdeaNode {
  id: string;
  text: string;
}

// Define the expected data input: the raw text dump.
interface MindMapWorkbenchProps {
  brainDumpText: string;
}

// This component performs real-time parsing and will eventually render the visual map.
export const MindMapWorkbench: React.FC<MindMapWorkbenchProps> = ({ brainDumpText }) => {
  const [ideaNodes, setIdeaNodes] = useState<IdeaNode[]>([]);

  // This hook executes the parsing logic whenever the text input changes.
  useEffect(() => {
    // Break the text dump by line breaks to get distinct ideas
    // We filter out empty lines caused by extra spaces.
    const lines = brainDumpText.split('\n').filter(line => line.trim().length > 0);
    
    // Convert lines into IdeaNode objects
    const newNodes = lines.map((text, index) => ({
      id: `node-${index}`, 
      text: text.trim(),
    }));
    
    setIdeaNodes(newNodes);
  }, [brainDumpText]);


  // Current view: displays the parsed nodes as separate visual blocks (the first stage of mapping)
  return (
    <div className="p-4 bg-white/70 backdrop-blur-sm rounded-lg shadow-inner flex-grow overflow-auto">
      <h4 className="font-semibold text-slate-700 mb-2">Parsed Idea Nodes (Pre-Visualization)</h4>
      
      {ideaNodes.length > 0 ? (
        <div className="space-y-3">
          {ideaNodes.map(node => (
            <p key={node.id} className="text-sm text-slate-800 p-2 bg-slate-100 rounded-md shadow-sm border border-slate-200">
              {node.text}
            </p>
          ))}
        </div>
      ) : (
        <pre className="text-sm text-slate-600 whitespace-pre-wrap p-2 bg-slate-50 rounded-md overflow-x-auto">
          {"Start typing or speaking your thoughts to see them map out here!"}
        </pre>
      )}
    </div>
  );
};
import React, { useState } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CapturedItem } from '../hooks/types';

interface OmniInboxProps {
    items: CapturedItem[];
    onDeleteItem: (itemId: string) => void;
    onPromoteToQuest: (itemId:string) => void;
    onAddQuest: (text: string) => void;
}

export const OmniInbox: React.FC<OmniInboxProps> = ({ items, onDeleteItem, onPromoteToQuest, onAddQuest }) => {
    const [analysis, setAnalysis] = useState<Record<string, { loading: boolean; suggestions: string[] | null; error: string | null; }>>({});

    const handleAnalyze = async (item: CapturedItem) => {
        setAnalysis(prev => ({ ...prev, [item.id]: { loading: true, suggestions: null, error: null } }));
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const prompt = `You are Sonia, a hyper-competent Chief of Staff. A "brain bean" has been captured with the following text: "${item.text}". Analyze this and suggest 1-3 concrete, actionable next steps. Format the response as a simple list with each step on a new line, prefixed with a hyphen. Do not add any intro, outro, or other commentary.`;
            
            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: prompt,
            });

            const suggestions = response.text
                .split('\n')
                .map(s => s.trim().replace(/^- /, ''))
                .filter(s => s.length > 0);

            setAnalysis(prev => ({ ...prev, [item.id]: { loading: false, suggestions, error: null } }));
        } catch (e) {
            console.error(e);
            setAnalysis(prev => ({ ...prev, [item.id]: { loading: false, suggestions: null, error: "Couldn't process this bean." } }));
        }
    };
    
    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center gap-3 mb-4 px-2 sm:px-0">
                <span className="text-3xl" aria-hidden="true">üì•</span>
                <h2 id="omni-inbox-heading" className="text-2xl font-bold text-slate-700 font-serif">Omni-Inbox</h2>
            </div>
            <div role="list" aria-labelledby="omni-inbox-heading" className="max-h-64 overflow-y-auto pr-2 space-y-3 custom-scrollbar">
                {items.length > 0 ? (
                    items.map(item => (
                        <div key={item.id} role="listitem" className="bg-white/70 p-3 rounded-lg shadow-sm border border-white/50 hover:bg-white/90 transition-all duration-200 group transform hover:scale-[1.02] hover:shadow-md">
                            <div className="flex justify-between items-center">
                                <p className="text-slate-800 text-left flex-grow mr-2">{item.text}</p>
                                <div className="flex-shrink-0 flex items-center gap-1">
                                    <button onClick={() => handleAnalyze(item)} disabled={analysis[item.id]?.loading} className="p-2 text-slate-400 hover:text-purple-500 hover:bg-purple-100 rounded-full transition-colors opacity-50 group-hover:opacity-100 disabled:opacity-50 disabled:cursor-not-allowed" aria-label={`Analyze: ${item.text}`} title="Analyze with AI">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clipRule="evenodd" /></svg>
                                    </button>
                                    <button onClick={() => onPromoteToQuest(item.id)} className="p-2 text-slate-400 hover:text-green-500 hover:bg-green-100 rounded-full transition-colors opacity-50 group-hover:opacity-100" aria-label={`Promote to Quest: ${item.text}`} title="Promote to Quest">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 9.414V13a1 1 0 102 0V9.414l1.293 1.293a1 1 0 001.414-1.414z" clipRule="evenodd" /></svg>
                                    </button>
                                    <button onClick={() => onDeleteItem(item.id)} className="p-2 text-slate-400 hover:text-red-500 hover:bg-red-100 rounded-full transition-colors opacity-50 group-hover:opacity-100" aria-label={`Delete item: ${item.text}`} title="Delete Item">
                                       <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" /></svg>
                                    </button>
                                </div>
                            </div>
                            {analysis[item.id]?.loading && <div className="text-center text-sm text-slate-500 mt-2">Sonia is thinking...</div>}
                            {analysis[item.id]?.error && <div className="text-center text-sm text-red-500 mt-2">{analysis[item.id]?.error}</div>}
                            {analysis[item.id]?.suggestions && (
                                <div className="mt-3 pt-3 border-t border-sky-200/50 space-y-2">
                                    <h4 className="font-semibold text-sm text-slate-600">Suggested Next Steps:</h4>
                                    {analysis[item.id]?.suggestions?.map((suggestion, i) => (
                                        <div key={i} className="flex items-center justify-between text-sm bg-sky-50/50 p-2 rounded-md">
                                            <p className="text-slate-700 flex-grow">{suggestion}</p>
                                            <button onClick={() => onAddQuest(suggestion)} className="ml-2 p-1.5 text-sky-500 hover:text-sky-700 hover:bg-sky-200 rounded-full transition-colors" aria-label={`Add quest: ${suggestion}`} title="Add as new Quest">
                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" /></svg>
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    ))
                ) : (
                    <div className="text-center py-8 px-4">
                        <span className="text-4xl">üïäÔ∏è</span>
                        <p className="mt-3 font-semibold text-slate-600">All clear!</p>
                        <p className="text-slate-500 text-sm">Your inbox is empty. A perfect time for a deep breath.</p>
                    </div>
                )}
            </div>
        </div>
    );
};
import React, { useState, useEffect } from 'react';
import { ONBOARDING_STEPS } from '../constants';
import { SoniaAvatar } from './CharacterAvatars';

interface OnboardingGuideProps {
    onFinish: () => void;
    onOpenCaptureModal: () => void;
    isCaptureModalOpen: boolean;
    inboxItemCount: number;
}

export const OnboardingGuide: React.FC<OnboardingGuideProps> = ({ onFinish, onOpenCaptureModal, isCaptureModalOpen, inboxItemCount }) => {
    const [stepIndex, setStepIndex] = useState(0);
    const [initialInboxCount, setInitialInboxCount] = useState(inboxItemCount);
    
    const currentStep = ONBOARDING_STEPS[stepIndex];
    const isCaptureQuest = currentStep.action === 'capture';

    // Auto-advance after capture quest is completed
    useEffect(() => {
        if (isCaptureQuest && !isCaptureModalOpen && inboxItemCount > initialInboxCount) {
            handleNext();
        }
    }, [isCaptureQuest, isCaptureModalOpen, inboxItemCount]);

    const handleNext = () => {
        if (stepIndex < ONBOARDING_STEPS.length - 1) {
            setStepIndex(stepIndex + 1);
        }
    };
    
    const handleActionClick = () => {
        switch(currentStep.action) {
            case 'capture':
                setInitialInboxCount(inboxItemCount);
                onOpenCaptureModal();
                break;
            case 'finish':
                onFinish();
                break;
            default:
                handleNext();
        }
    };

    return (
        <div className="fixed inset-0 bg-slate-900/40 z-50 flex items-center justify-center p-4 backdrop-blur-lg animate-fade-in">
            <div className="relative bg-white/80 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-2xl p-8 transform transition-all animate-fade-in-up">
                <div className="flex flex-col sm:flex-row items-center text-center sm:text-left gap-6">
                    <div className="w-24 h-24 sm:w-32 sm:h-32 rounded-full bg-sky-400 p-2 flex-shrink-0 shadow-lg">
                        <SoniaAvatar />
                    </div>
                    <div>
                        <p className="text-xl text-slate-700 leading-relaxed transition-opacity duration-500" key={stepIndex}>
                            {currentStep.dialogue}
                        </p>
                        <button 
                            onClick={handleActionClick}
                            className="mt-6 px-8 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md transition-colors"
                        >
                            {currentStep.actionText}
                        </button>
                    </div>
                </div>
                 <button 
                    onClick={onFinish}
                    className="absolute bottom-4 right-6 text-sm font-medium text-slate-500 hover:text-slate-800 transition-colors"
                >
                    Skip Introduction
                </button>
            </div>
        </div>
    );
};
import React, { useEffect, useState } from 'react';

interface PraiseToastProps {
    message: string;
    onClose: () => void;
}

export const PraiseToast: React.FC<PraiseToastProps> = ({ message, onClose }) => {
    const [isExiting, setIsExiting] = useState(false);

    useEffect(() => {
        const timer = setTimeout(() => {
            setIsExiting(true);
            const exitTimer = setTimeout(onClose, 300); // Allow time for exit animation
            return () => clearTimeout(exitTimer);
        }, 2500);

        return () => clearTimeout(timer);
    }, [onClose]);

    return (
        <div 
            className={`fixed bottom-8 left-1/2 -translate-x-1/2 z-50 bg-slate-800 text-white font-semibold px-6 py-3 rounded-full shadow-lg transition-all duration-300 ${isExiting ? 'opacity-0 translate-y-4' : 'opacity-100 translate-y-0'}`}
        >
            <span role="img" aria-label="sparkles" className="mr-2">‚ú®</span> 
            {message} 
        </div>
    );
};
import React, { useState } from 'react';
import { GoogleGenAI, Type } from "@google/genai";

interface ProactiveTriageProps {
    onAddQuest: (text: string) => void;
}

interface TriageItem {
    sourceText: string;
    suggestion: {
        task?: string;
        responseOptions?: string[];
    }
}

// Hardcoded sample data for simulation
const SIMULATED_INBOX = [
    "Email from 'Client A': 'Invoice due next Friday.'",
    "Calendar invite from 'Team Lead': 'Sync up on Project X tomorrow at 10am'",
    "Email from 'Marketing Dept': 'Weekly newsletter is out!'",
    "Email from 'Potential Partner': 'Can we meet next week to discuss collaboration?'",
    "Email from 'IT Support': 'Reminder: Scheduled maintenance this Saturday at 2 AM.'"
].join('\n');


export const ProactiveTriage: React.FC<ProactiveTriageProps> = ({ onAddQuest }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [triageItems, setTriageItems] = useState<TriageItem[] | null>(null);
    const [copiedResponse, setCopiedResponse] = useState<string | null>(null);

    const handleScan = async () => {
        setIsLoading(true);
        setError(null);
        setTriageItems(null);

        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const response = await ai.models.generateContent({
                model: "gemini-2.5-flash",
                contents: `You are Sonia, a hyper-competent Chief of Staff specializing in proactive assistance. Your task is to analyze a list of simulated email subjects and snippets.
                
                Scan the following items for trigger phrases like 'Invoice due...', 'Can we meet...', 'Follow up', 'Action required', 'sync up', etc. For each actionable item you find, you must suggest EITHER a single concrete task OR three simple, one-sentence response options. Ignore any non-actionable items.
                
                Here are the latest items:
                ${SIMULATED_INBOX}`,
                config: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: Type.ARRAY,
                        items: {
                            type: Type.OBJECT,
                            properties: {
                                sourceText: { type: Type.STRING, description: "The original email or calendar item text." },
                                suggestion: {
                                    type: Type.OBJECT,
                                    properties: {
                                        task: { type: Type.STRING, description: "A suggested task to add to the quest log. Provide this OR responseOptions." },
                                        responseOptions: {
                                            type: Type.ARRAY,
                                            description: "Three short, one-sentence response options. Provide this OR a task.",
                                            items: { type: Type.STRING }
                                        }
                                    }
                                }
                            },
                            required: ["sourceText", "suggestion"]
                        },
                    },
                },
            });

            setTriageItems(JSON.parse(response.text));

        } catch (e) {
            console.error(e);
            setError("Sonia had trouble scanning your items. Please try again in a moment.");
        } finally {
            setIsLoading(false);
        }
    };

    const handleAddTask = (task: string, index: number) => {
        onAddQuest(task);
        // Remove item from list after actioning
        setTriageItems(prev => prev ? prev.filter((_, i) => i !== index) : null);
    };

    const handleCopyResponse = (text: string) => {
        navigator.clipboard.writeText(text);
        setCopiedResponse(text);
        setTimeout(() => setCopiedResponse(null), 2000);
    };

    const handleDismiss = (index: number) => {
        setTriageItems(prev => prev ? prev.filter((_, i) => i !== index) : null);
    };


    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center gap-3 mb-2">
                <span className="text-3xl" aria-hidden="true">‚ö°Ô∏è</span>
                <h2 className="text-2xl font-bold text-slate-700 font-serif">Proactive Triage</h2>
            </div>
            <p className="text-slate-600 mb-4 text-sm">Let Sonia scan your (simulated) inbox & calendar for actionable items.</p>

            {!triageItems && (
                <button onClick={handleScan} disabled={isLoading} className="w-full px-6 py-2 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-800 transition-all disabled:opacity-50">
                    {isLoading ? "Scanning..." : "Scan for Actionable Items"}
                </button>
            )}
            
            {error && <p className="text-red-500 text-center font-medium mt-4">{error}</p>}

            {triageItems && (
                <div className="mt-4 space-y-4 max-h-80 overflow-y-auto custom-scrollbar pr-2">
                    {triageItems.length === 0 && !isLoading && (
                        <p className="text-center text-slate-500 font-semibold py-4">All clear! Nothing needed your immediate attention.</p>
                    )}
                    {triageItems.map((item, index) => (
                        <div key={index} className="p-4 bg-stone-100/50 rounded-lg border border-stone-200/50 animate-fade-in-up">
                            <div className="flex justify-between items-start">
                                <p className="text-sm italic text-slate-600 mb-2">"{item.sourceText}"</p>
                                <button onClick={() => handleDismiss(index)} className="p-1 text-slate-400 hover:text-red-500" title="Dismiss">
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" /></svg>
                                </button>
                            </div>
                            
                            {item.suggestion.task && (
                                <div className="flex items-center justify-between p-2 bg-white/70 rounded-md">
                                    <p className="text-slate-800 font-semibold">{item.suggestion.task}</p>
                                    <button onClick={() => handleAddTask(item.suggestion.task!, index)} className="px-3 py-1 bg-green-500 text-white text-sm font-semibold rounded-full hover:bg-green-600">
                                        Add to Quests
                                    </button>
                                </div>
                            )}

                            {item.suggestion.responseOptions && (
                                <div className="space-y-2 mt-2">
                                    <p className="text-sm font-semibold text-slate-700">Suggested Responses:</p>
                                    {item.suggestion.responseOptions.map((resp, i) => (
                                         <button key={i} onClick={() => handleCopyResponse(resp)} className="w-full text-left p-2 bg-white/70 rounded-md hover:bg-slate-200/80 text-slate-800 transition-colors text-sm">
                                            {copiedResponse === resp ? "Copied!" : `"${resp}"`}
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};
import React, { useState, useEffect } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CapturedItem, CharacterData } from '../hooks/types';

interface ProcrastinationInterventionProps {
    quest: CapturedItem;
    character: CharacterData;
    onAcknowledge: () => void;
}

export const ProcrastinationIntervention: React.FC<ProcrastinationInterventionProps> = ({ quest, character, onAcknowledge }) => {
    const [isLoading, setIsLoading] = useState(true);
    const [reflection, setReflection] = useState<string | null>(null);

    useEffect(() => {
        const generateReflection = async () => {
            setIsLoading(true);
            try {
                const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
                const prompt = `You are ${character.name}, a calm and empathetic guide. The user seems to be repeatedly postponing the following task: "${quest.text}".
                
                Gently help them explore why, without judgment. Ask one or two reflective questions to help them uncover the emotional block or fear behind the procrastination. Do not offer solutions. Just create a safe space for reflection. Keep your response brief, compassionate, and start by acknowledging the task.`;
                
                const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
                setReflection(response.text);

            } catch (e) {
                console.error(e);
                setReflection("It seems there's some friction with this task. How does it make you feel when you think about it?");
            } finally {
                setIsLoading(false);
            }
        };

        generateReflection();
    }, [quest.id, quest.text, character.name]);

    return (
        <div className="p-4 sm:p-6 bg-amber-50/70 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-amber-200/50 font-sans">
            <div className="flex items-center gap-3 mb-2">
                 <span className="text-2xl flex-shrink-0" aria-hidden="true">üí¨</span>
                 <h2 className="text-xl font-bold text-slate-700 font-serif">A Gentle Reflection</h2>
            </div>
            {isLoading ? (
                <p className="text-slate-600">Sister Mary is gathering her thoughts...</p>
            ) : (
                <p className="text-slate-800 whitespace-pre-wrap leading-relaxed">{reflection}</p>
            )}
            <button 
                onClick={onAcknowledge}
                className="mt-4 w-full text-sm font-semibold text-slate-600 hover:text-slate-800 transition-colors py-2 bg-white/50 rounded-lg border border-white"
            >
                Acknowledge and Dismiss
            </button>
        </div>
    )
};
import React, { useState } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CapturedItem, CharacterData } from '../hooks/types';

interface ProjectBriefsProps {
    questItems: CapturedItem[];
    inboxItems: CapturedItem[];
    completedQuests: CapturedItem[];
    characters: CharacterData[];
}

export const ProjectBriefs: React.FC<ProjectBriefsProps> = ({ questItems, inboxItems, completedQuests, characters }) => {
    const [selectedQuestId, setSelectedQuestId] = useState<string>('');
    const [isLoading, setIsLoading] = useState(false);
    const [brief, setBrief] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);

    const handleGenerateBrief = async () => {
        const selectedQuest = questItems.find(q => q.id === selectedQuestId);
        if (!selectedQuest) return;

        setIsLoading(true);
        setBrief(null);
        setError(null);

        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const prompt = `You are Sonia, a hyper-competent Chief of Staff. Your task is to generate a project brief for a specific quest.
Analyze the user's entire digital ecosystem to find relevant context.

**SELECTED QUEST:**
"${selectedQuest.text}"

**DIGITAL ECOSYSTEM (All user notes, tasks, and completed items):**
Inbox Items:
${inboxItems.map(i => `- ${i.text}`).join('\n') || 'None'}

Active Quests:
${questItems.map(q => `- ${q.text}`).join('\n') || 'None'}

Completed Trophies:
${completedQuests.map(c => `- ${c.text}`).join('\n') || 'None'}

**YOUR TEAM (Potential Collaborators):**
${characters.map(c => `- ${c.name}, ${c.title}`).join('\n')}

**INSTRUCTIONS:**
Based on all the information above, create a concise project brief for the selected quest. The brief should include:
1.  **Summary:** A one-sentence summary of the objective.
2.  **Related Notes:** Pull out 1-3 relevant notes or tasks from the ecosystem that might be related. If none, state that.
3.  **Suggested Collaborators:** Suggest 1-2 team members who could help and briefly explain why.
4.  **Proposed Next Steps:** Suggest 2-3 immediate, actionable next steps to get started.

Format the output in clean Markdown using headings (e.g., "### Summary").`;
            
            const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
            setBrief(response.text);

        } catch (e) {
            console.error(e);
            setError("I had trouble generating the brief. Please try again.");
        } finally {
            setIsLoading(false);
        }
    }

    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center gap-3 mb-2">
                <span className="text-3xl" aria-hidden="true">üìÑ</span>
                <h2 className="text-2xl font-bold text-slate-700 font-serif">Project Briefs</h2>
            </div>
            <p className="text-slate-600 mb-4 text-sm">Let Sonia analyze a quest and prepare a strategic brief for you.</p>

            {questItems.length > 0 ? (
                <div className="flex flex-col sm:flex-row gap-2">
                    <select
                        value={selectedQuestId}
                        onChange={e => setSelectedQuestId(e.target.value)}
                        className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner"
                    >
                        <option value="" disabled>Select a quest to analyze...</option>
                        {questItems.map(quest => (
                            <option key={quest.id} value={quest.id}>{quest.text}</option>
                        ))}
                    </select>
                    <button 
                        onClick={handleGenerateBrief} 
                        disabled={!selectedQuestId || isLoading}
                        className="px-6 py-2 bg-gradient-to-br from-sky-500 to-blue-500 text-white font-semibold rounded-lg shadow-lg shadow-sky-500/30 hover:from-sky-600 hover:to-blue-600 transition-all disabled:from-sky-400 disabled:to-blue-400 disabled:shadow-none disabled:cursor-not-allowed flex-shrink-0"
                    >
                        {isLoading ? "Analyzing..." : "Generate Brief"}
                    </button>
                </div>
            ) : (
                <p className="text-center text-slate-500 text-sm py-4">You need active quests to generate a brief.</p>
            )}

            {error && <p className="text-red-500 text-center font-medium mt-4">{error}</p>}
            
            {brief && (
                <div className="mt-4 p-4 bg-sky-50/50 rounded-lg border border-sky-200/50 animate-fade-in prose prose-slate max-w-none prose-h3:font-serif prose-h3:text-slate-700">
                    {brief.split('\n').map((line, i) => {
                        if (line.startsWith('### ')) return <h3 key={i} className="font-bold mt-4 mb-1">{line.replace('### ', '')}</h3>
                        if (line.startsWith('- ')) return <p key={i} className="my-1">{line}</p>
                        return <p key={i} className="my-1">{line}</p>
                    })}
                </div>
            )}
        </div>
    );
};
import React from 'react';
import { CapturedItem } from '../hooks/types';

interface QuestLogProps {
    items: CapturedItem[];
    onCompleteQuest: (itemId: string) => void;
    onStartBossBattle: (item: CapturedItem) => void;
    onPostponeQuest: (itemId: string) => void;
    isFocusMode: boolean;
    onToggleFocusMode: (enabled: boolean) => void;
    focusQuestId: string | null;
    isFocusLoading: boolean;
    focusError: string | null;
}

const QuestItem: React.FC<{
    item: CapturedItem;
    index: number;
    onPostponeQuest: (itemId: string) => void;
    onStartBossBattle: (item: CapturedItem) => void;
    handleComplete: (e: React.MouseEvent<HTMLButtonElement>, itemId: string) => void;
    isFocus?: boolean;
}> = ({ item, index, onPostponeQuest, onStartBossBattle, handleComplete, isFocus = false }) => (
    <div 
        role="listitem"
        className={`bg-white/70 p-3 rounded-lg shadow-sm flex justify-between items-center border border-white/50 group animate-fade-in-up ${isFocus ? 'ring-2 ring-indigo-400 shadow-lg' : ''}`}
        style={{ animationDelay: `${index * 50}ms`}}
    >
        <p className="text-slate-800 text-left flex-grow mr-2">{item.text} {item.postponedCount && item.postponedCount > 0 ? `(${item.postponedCount})` : ''}</p>
        <div className="flex-shrink-0 flex items-center gap-1">
            <button 
                onClick={() => onPostponeQuest(item.id)}
                className="p-2 text-slate-400 hover:text-yellow-600 hover:bg-yellow-100 rounded-full transition-colors opacity-50 group-hover:opacity-100"
                aria-label={`Postpone quest: ${item.text}`}
                title="Postpone Quest"
            >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.414-1.415L11 9.586V6z" clipRule="evenodd" />
                </svg>
            </button>
            <button 
                onClick={() => onStartBossBattle(item)}
                className="p-2 text-slate-400 hover:text-red-500 hover:bg-red-100 rounded-full transition-colors opacity-50 group-hover:opacity-100"
                aria-label={`Start Boss Battle for: ${item.text}`}
                title="Start Boss Battle"
            >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M18 3a1 1 0 00-1.447-.894L8.763 6H5a3 3 0 000 6h.28l1.771 5.316A1 1 0 008 18h1a1 1 0 001-1v-2.382l6.553 3.276A1 1 0 0018 17V3z" />
                </svg>
            </button>
            <button 
                onClick={(e) => handleComplete(e, item.id)}
                className="px-4 py-1.5 bg-emerald-600 text-white font-semibold rounded-full hover:bg-emerald-700 transition-all shadow-sm text-sm transform group-hover:scale-105"
                aria-label={`Complete quest: ${item.text}`}
                title="Complete Quest"
            >
                Complete
            </button>
        </div>
    </div>
);


export const QuestLog: React.FC<QuestLogProps> = ({ items, onCompleteQuest, onStartBossBattle, onPostponeQuest, isFocusMode, onToggleFocusMode, focusQuestId, isFocusLoading, focusError }) => {
    
    const handleComplete = (e: React.MouseEvent<HTMLButtonElement>, itemId: string) => {
        onCompleteQuest(itemId);
    }
    
    const focusQuest = items.find(item => item.id === focusQuestId);
    
    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center justify-between gap-3 mb-4 px-2 sm:px-0">
                <div className="flex items-center gap-3">
                    <span className="text-3xl" aria-hidden="true">üó∫Ô∏è</span>
                    <h2 id="quest-log-heading" className="text-2xl font-bold text-slate-700 font-serif">Quest Log</h2>
                </div>
                {items.length > 0 && (
                    <div className="flex items-center gap-2">
                        <label htmlFor="focus-toggle" className="text-sm font-semibold text-slate-600 cursor-pointer">Focus Mode</label>
                        <button
                            role="switch"
                            aria-checked={isFocusMode}
                            id="focus-toggle"
                            onClick={() => onToggleFocusMode(!isFocusMode)}
                            className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 ${isFocusMode ? 'bg-indigo-500' : 'bg-slate-300'}`}
                        >
                            <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${isFocusMode ? 'translate-x-6' : 'translate-x-1'}`} />
                        </button>
                    </div>
                )}
            </div>
            
            {focusError && <p className="text-red-500 text-center text-sm mb-2">{focusError}</p>}

            <div role="list" aria-labelledby="quest-log-heading" className="max-h-80 overflow-y-auto pr-2 space-y-3 custom-scrollbar">
                {isFocusLoading ? (
                    <div className="text-center py-8 px-4">
                        <p className="font-semibold text-slate-600 animate-pulse">Sonia is focusing...</p>
                    </div>
                ) : isFocusMode ? (
                    focusQuest ? (
                        <QuestItem item={focusQuest} index={0} onPostponeQuest={onPostponeQuest} onStartBossBattle={onStartBossBattle} handleComplete={handleComplete} isFocus={true} />
                    ) : (
                        <div className="text-center py-8 px-4">
                            <p className="font-semibold text-slate-600">No focus quest identified.</p>
                            <p className="text-slate-500 text-sm">Turn off Focus Mode to see all quests.</p>
                        </div>
                    )
                ) : items.length > 0 ? (
                    items.map((item, index) => (
                        <QuestItem key={item.id} item={item} index={index} onPostponeQuest={onPostponeQuest} onStartBossBattle={onStartBossBattle} handleComplete={handleComplete} />
                    ))
                ) : (
                     <div className="text-center py-8 px-4">
                        <span className="text-4xl">üßò</span>
                        <p className="mt-3 font-semibold text-slate-600">The path is clear.</p>
                        <p className="text-slate-500 text-sm">Promote an item from your inbox to start a new quest.</p>
                    </div>
                )}
            </div>
        </div>
    );
};
import React from 'react';

interface SanctuaryModeToggleProps {
    enabled: boolean;
    onToggle: () => void;
}

export const SanctuaryModeToggle: React.FC<SanctuaryModeToggleProps> = ({ enabled, onToggle }) => {
    return (
        <button
            onClick={onToggle}
            title={enabled ? "Disable Sanctuary Mode" : "Enable Sanctuary Mode"}
            className="w-10 h-10 flex items-center justify-center rounded-full transition-colors duration-300 bg-slate-800 text-white/80 hover:bg-slate-700 hover:text-white"
        >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" />
            </svg>
        </button>
    );
};
import React, { useState } from 'react';
import { CapturedItem } from '../hooks/types';

interface SomedayMaybeSafariProps {
    items: CapturedItem[];
    onPromoteToQuest: (itemId: string) => void;
    onDeleteItem: (itemId: string) => void;
    onBack: () => void;
}

export const SomedayMaybeSafari: React.FC<SomedayMaybeSafariProps> = ({ items, onPromoteToQuest, onDeleteItem, onBack }) => {
    const [currentIndex, setCurrentIndex] = useState(0);

    const handleNext = () => {
        if (items.length > 0) {
            setCurrentIndex((prevIndex) => (prevIndex + 1) % items.length);
        }
    };
    
    const handlePromote = (itemId: string) => {
        onPromoteToQuest(itemId);
        if (items.length <= 1) { 
            onBack();
        } else if (currentIndex >= items.length - 1) {
             setCurrentIndex(0);
        }
    }
    
    const handleDelete = (itemId: string) => {
        onDeleteItem(itemId);
         if (items.length <= 1) {
            onBack();
        } else if (currentIndex >= items.length - 1) {
             setCurrentIndex(0);
        }
    }

    const currentItem = items.length > 0 ? items[currentIndex] : null;

    return (
        <div className="w-full max-w-2xl bg-stone-100/70 backdrop-blur-sm rounded-2xl shadow-lg border border-stone-200/50 font-sans flex flex-col animate-fade-in-up p-4 sm:p-6 text-center">
            <div className="flex items-center justify-between">
                 <div className="flex items-center gap-3">
                    <span className="text-3xl" aria-hidden="true">üß≠</span>
                    <h2 className="text-2xl font-bold text-slate-700 font-serif">Someday/Maybe Safari</h2>
                </div>
                 <button onClick={onBack} className="px-4 py-2 bg-slate-200/70 text-slate-800 font-semibold rounded-lg hover:bg-slate-300/80 transition-colors shadow-sm text-sm">Back to Hub</button>
            </div>
           
            <p className="text-slate-600 my-4 text-sm max-w-md mx-auto">
                "It's time for our 'Someday/Maybe Safari.' We're not here to do anything, just to admire the magnificent ideas we've captured."
            </p>

            <div className="flex-grow flex flex-col items-center justify-center p-4 min-h-[200px]">
                {currentItem ? (
                    <div className="w-full p-6 bg-yellow-200 shadow-lg rounded-md border border-yellow-300 transform -rotate-1 animate-fade-in">
                        <p className="font-serif text-xl text-slate-800">{currentItem.text}</p>
                    </div>
                ) : (
                    <div className="text-center py-8 px-4">
                        <span className="text-4xl">ü¶ã</span>
                        <p className="mt-3 font-semibold text-slate-600">The safari is quiet today.</p>
                        <p className="text-slate-500 text-sm">Your Omni-Inbox is empty of old ideas. Capture some new ones!</p>
                    </div>
                )}
            </div>

            {currentItem && (
                <div className="flex flex-col sm:flex-row justify-center items-center gap-3 mt-4">
                    <button onClick={() => handleDelete(currentItem.id)} className="px-4 py-2 bg-white/80 text-red-600 font-semibold rounded-lg shadow-sm hover:bg-red-50 transition-colors">Let it Go</button>
                    <button onClick={handleNext} className="px-6 py-3 bg-gradient-to-br from-yellow-500 to-orange-500 text-white font-semibold rounded-lg shadow-lg shadow-yellow-500/30 hover:from-yellow-600 hover:to-orange-600 transition-all">Next Idea</button>
                    <button onClick={() => handlePromote(currentItem.id)} className="px-4 py-2 bg-white/80 text-green-600 font-semibold rounded-lg shadow-sm hover:bg-green-50 transition-colors">Make it a Quest</button>
                </div>
            )}
        </div>
    );
};
import { MindMapWorkbench } from './MindMapWorkbench';
import React, { useState, useEffect, useRef } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import { ExtractedItem, CharacterData, HubId } from '../hooks/types';
import { SoniaAvatar, SisterMaryAvatar } from './CharacterAvatars';
import { MindMapWorkbench } from './MindMapWorkbench';

interface StrategicSinterprops {
    onFinish: () => void;
    onBulkAddItems: (items: ExtractedItem[]) => void;
    characters: CharacterData[];
}

type HuddleStep = 'intro' | 'braindump' | 'review' | 'advice' | 'outro';

// Non-standard browser API, so we need to declare it
declare global {
    interface Window {
        SpeechRecognition: any;
        webkitSpeechRecognition: any;
    }
}

export const StrategicSinter: React.FC<StrategicSinterprops> = ({ onFinish, onBulkAddItems, characters }) => {
    const [step, setStep] = useState<HuddleStep>('intro');
    const [brainDumpText, setBrainDumpText] = useState('');
    const [whiteboardPoints, setWhiteboardPoints] = useState<string[]>([]);
    const [extractedItems, setExtractedItems] = useState<ExtractedItem[]>([]);
    const [selectedItems, setSelectedItems] = useState<Record<string, boolean>>({});
    const [advice, setAdvice] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [isListening, setIsListening] = useState(false);
    const recognitionRef = useRef<any>(null);

    const sisterMary = characters.find(c => c.id === HubId.SisterMary);

    useEffect(() => {
        if (step === 'braindump') {
            const points = brainDumpText
                .split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            setWhiteboardPoints(points);
        }
    }, [brainDumpText, step]);
    
    // Cleanup effect for speech recognition
    useEffect(() => {
        return () => {
            recognitionRef.current?.stop();
        };
    }, []);

    const handleAnalyzeDump = async () => {
        setIsLoading(true);
        setError(null);
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const response = await ai.models.generateContent({
                model: "gemini-2.5-flash",
                contents: `You are Sonia, a hyper-competent Chief of Staff. Analyze the following "brain dump" from the user and extract all distinct thoughts, ideas, or to-do items. For each item, classify it as either a simple 'inbox' capture or a more concrete 'quest'.
                
                Brain Dump:
                "${brainDumpText}"`,
                config: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: Type.ARRAY,
                        items: {
                            type: Type.OBJECT,
                            properties: {
                                text: { type: Type.STRING, description: "The text of the captured item." },
                                type: { type: Type.STRING, description: "The type of item.", enum: ["inbox", "quest"] }
                            },
                            required: ["text", "type"]
                        },
                    },
                },
            });
            
            const parsedItems = JSON.parse(response.text) as ExtractedItem[];
            setExtractedItems(parsedItems);
            setSelectedItems(parsedItems.reduce((acc, item, index) => ({...acc, [`${index}`]: true }), {}));
            setStep('review');

        } catch (e) {
            console.error(e);
            setError("Sonia had some trouble parsing that. Could you try rephrasing?");
        } finally {
            setIsLoading(false);
        }
    };
    
    const handleConfirmItems = async () => {
        setIsLoading(true);
        const itemsToAdd = extractedItems.filter((_, index) => selectedItems[`${index}`]);
        onBulkAddItems(itemsToAdd);

        // Fetch advice from Sister Mary in parallel
        if (sisterMary) {
            try {
                const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
                const response = await ai.models.generateContent({
                    model: 'gemini-2.5-flash',
                    contents: `${sisterMary.basePrompt}\nBased on the user's brain dump, provide one short, powerful sentence of strategic advice or encouragement. Brain Dump: "${brainDumpText}"`
                });
                setAdvice(response.text);
            } catch (e) {
                console.error(e);
                setAdvice("Remember to lead with your values today.");
            }
        }
        
        setIsLoading(false);
        setStep('advice');
    };
    
    const handleMicClick = () => {
        if (isListening) {
            recognitionRef.current?.stop();
            return;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            setError("Sorry, your browser doesn't support speech recognition.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognitionRef.current = recognition;
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        const initialText = brainDumpText.trim().length > 0 ? brainDumpText.trim() + '\n' : '';

        recognition.onstart = () => {
            setIsListening(true);
            setError(null);
        };

        recognition.onend = () => {
            setIsListening(false);
        };

        recognition.onerror = (event: any) => {
            console.error('Speech recognition error', event.error);
            setError(`Mic error: ${event.error}`);
            setIsListening(false);
        };

        recognition.onresult = (event: any) => {
            let transcript = '';
            for (let i = 0; i < event.results.length; ++i) {
                transcript += event.results[i][0].transcript;
                 if (event.results[i].isFinal) {
                    transcript += '\n';
                }
            }
            setBrainDumpText(initialText + transcript.replace(/\n\n/g, '\n'));
        };

        recognition.start();
    };

    const renderStepContent = () => {
        switch (step) {
           case 'intro': return (
    <>
        <div className="w-24 h-24 sm:w-32 sm:h-32 rounded-full bg-sky-400 p-2 flex-shrink-0 shadow-lg mx-auto mb-6"><SoniaAvatar /></div>
        <h2 className="text-3xl font-bold text-slate-800 font-serif">The Strategic Sinter</h2>
        <p className="text-lg text-slate-700 leading-relaxed mt-4">C'est parfait! It's Midday. Let's fire up the forge and transmute the chaos into clear, rock-solid action steps for your prime work block.</p>
        <button onClick={() => setStep('braindump')} className="mt-8 px-8 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md transition-colors">Begin Transmutation</button>
    </>
);
            
case 'braindump': return (
    <>
        <h2 className="text-2xl font-bold text-slate-700 font-serif mb-2">The Brain Dump</h2>
        <p className="text-slate-600 mb-4">What's on your mind? Type or use the mic. We'll sort it out together.</p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 text-left">
            <div className="relative">
                <textarea 
                    value={brainDumpText} 
                    onChange={e => setBrainDumpText(e.target.value)} 
                    rows={12} 
                    className="w-full p-3 pr-12 bg-white/60 border-2 border-slate-300/40 rounded-lg shadow-inner" 
                    placeholder="Ideas, tasks, worries..."
                />
                <button 
                    type="button"
                    onClick={handleMicClick}
                    className={`absolute top-3 right-3 p-2 rounded-full transition-colors ${isListening ? 'bg-red-500 text-white animate-pulse' : 'bg-slate-200/50 text-slate-600 hover:bg-slate-300/70'}`}
                    title={isListening ? "Stop listening" : "Start listening"}
                >
                    {/* ICON GOES HERE */}
                </button>
                {error && (
                    <p className="text-red-500 text-sm mt-2">{error}</p>
                )}
            </div>
            
            <div className="relative"> 
                <h3 className="text-xl font-semibold text-slate-700 font-serif mb-2">Mind-Map Workbench</h3>
                <p className="text-sm text-slate-600 mb-4">Real-Time Visual Scaffold</p>
                
                <MindMapWorkbench brainDumpText={brainDumpText} />

                <button 
                    onClick={handleAnalyzeDump} 
                    disabled={isLoading} 
                    className="mt-8 px-8 py-3 bg-indigo-500 hover:bg-indigo-600 text-white font-semibold rounded-lg shadow-md transition-colors"
                >
                    {isLoading ? "Sonia is analyzing..." : "Analyze My Thoughts"}
                </button>
            </div>
        </div>
    </>
);
             case 'review': return (
                <>
                    <h2 className="text-2xl font-bold text-slate-700 font-serif mb-2">Sonia's Suggestions</h2>
                    <p className="text-slate-600 mb-4">Here's what I've extracted. Uncheck anything you don't want to add.</p>
                    <div className="max-h-60 overflow-y-auto custom-scrollbar pr-2 space-y-2 text-left">
                        {extractedItems.map((item, index) => (
                            <div key={index} className="flex items-center p-2 bg-white/60 rounded-md">
                                <input type="checkbox" id={`item-${index}`} checked={selectedItems[`${index}`] || false} onChange={() => setSelectedItems(prev => ({...prev, [`${index}`]: !prev[`${index}`]}))} className="w-5 h-5 rounded text-indigo-500 mr-3" />
                                <label htmlFor={`item-${index}`} className="flex-grow text-slate-800">{item.text}</label>
                                <span className={`text-xs font-semibold px-2 py-0.5 rounded-full ${item.type === 'quest' ? 'bg-sky-200 text-sky-800' : 'bg-purple-200 text-purple-800'}`}>{item.type}</span>
                            </div>
                        ))}
                    </div>
                    <button onClick={handleConfirmItems} className="mt-4 w-full px-8 py-3 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold rounded-lg shadow-md">Add to Lists</button>
                </>
            );
             case 'advice': return (
                <>
                    <div className="w-24 h-24 sm:w-32 sm:h-32 rounded-full bg-slate-400 p-2 flex-shrink-0 shadow-lg mx-auto mb-6"><SisterMaryAvatar /></div>
                    <h2 className="text-2xl font-bold text-slate-700 font-serif">A Word from Sister Mary</h2>
                     {isLoading ? <p className="text-lg text-slate-700 leading-relaxed mt-4">Thinking...</p> : <p className="text-lg text-slate-700 leading-relaxed mt-4 italic">"{advice}"</p>}
                    <button onClick={() => setStep('outro')} className="mt-8 px-8 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md">Continue</button>
                </>
            );
            case 'outro': return (
                <>
                    <div className="w-24 h-24 sm:w-32 sm:h-32 rounded-full bg-sky-400 p-2 flex-shrink-0 shadow-lg mx-auto mb-6"><SoniaAvatar /></div>
                    <h2 className="text-3xl font-bold text-slate-800 font-serif">Huddle Complete</h2>
                    <p className="text-lg text-slate-700 leading-relaxed mt-4">Excellent. Your lists are updated and you have your focus for the day. The bridge is yours, mon capitaine.</p>
                    <button onClick={onFinish} className="mt-8 px-8 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md">Finish Huddle</button>
                </>
            );
        }
    }

    return (
        <div className="fixed inset-0 bg-slate-900/40 z-50 flex items-center justify-center p-4 backdrop-blur-lg animate-fade-in">
            <div className={`relative bg-white/80 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full ${step === 'braindump' ? 'max-w-4xl' : 'max-w-2xl'} p-8 text-center transform transition-all animate-fade-in-up`}>
                {renderStepContent()}
            </div>
        </div>
    )
};
import React, { useState } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CharacterData, CapturedItem } from '../hooks/types';

interface SundaySermonetteProps {
    character: CharacterData;
    completedQuests: CapturedItem[];
}

export const SundaySermonette: React.FC<SundaySermonetteProps> = ({ character, completedQuests }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [sermon, setSermon] = useState<string | null>(null);
    const [error, setError] = useState<string | null>(null);

    const handleGenerate = async () => {
        setIsLoading(true);
        setSermon(null);
        setError(null);

        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            
            const completedTexts = completedQuests.length > 0 
                ? completedQuests.map(q => `- ${q.text}`).join('\n')
                : "The user hasn't completed any quests this week. Reflect on the value of rest and preparation.";

            const prompt = `You are ${character.name}, the ${character.title}. Your personality is calm, reflective, and empathetic. Your goal is to provide support for emotional regulation, reframing negative self-talk, and connecting daily tasks to deeper meaning and values.
            
            Based on the following completed tasks from this past week, deliver a short, personalized weekly reflection (a "Sunday Sermonette"). It should connect a spiritual or philosophical theme to the user's actual logged activities and challenges. Keep it under 150 words.
            
            Completed tasks:
            ${completedTexts}`;

            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: prompt,
            });

            setSermon(response.text);

        } catch (e) {
            console.error(e);
            setError('Could not generate reflection at this time.');
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center gap-3 mb-4">
                <span className="text-3xl" aria-hidden="true">üïØÔ∏è</span>
                <h2 className="text-2xl font-bold text-slate-700 font-serif">The Sunday Sermonette</h2>
            </div>
            <p className="text-slate-600 mb-4 text-sm">An opt-in weekly reflection to connect your efforts to your values.</p>
            
            <button 
                onClick={handleGenerate} 
                disabled={isLoading}
                className="w-full px-6 py-2 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-800 transition-all disabled:bg-slate-400 disabled:shadow-none disabled:cursor-not-allowed"
            >
                {isLoading ? 'Reflecting...' : 'Receive Weekly Reflection'}
            </button>

            {error && <p className="text-red-500 text-center font-medium mt-4">{error}</p>}
            
            {sermon && (
                <div className="mt-4 p-4 bg-stone-100/50 rounded-lg border border-stone-200/50 animate-fade-in">
                    <p className="text-slate-800 whitespace-pre-wrap leading-relaxed">{sermon}</p>
                </div>
            )}
        </div>
    );
};
import React, { useState, useEffect } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import { CapturedItem, CharacterData, HubId } from '../hooks/types';
import { SoniaAvatar, SisterMaryAvatar } from './CharacterAvatars';

interface TeamHuddleProps {
    onClose: () => void;
    questItems: CapturedItem[];
    inboxItems: CapturedItem[];
    characters: CharacterData[];
}

interface HuddleDialogue {
    sonia_dialogue: string;
    sister_mary_dialogue: string;
}

export const TeamHuddle: React.FC<TeamHuddleProps> = ({ onClose, questItems, inboxItems, characters }) => {
    const [isLoading, setIsLoading] = useState(true);
    const [dialogue, setDialogue] = useState<HuddleDialogue | null>(null);
    const [error, setError] = useState<string | null>(null);

    const sonia = characters.find(c => c.id === HubId.Sonia);
    const sisterMary = characters.find(c => c.id === HubId.SisterMary);

    useEffect(() => {
        const generateDialogue = async () => {
            if (!sonia || !sisterMary) {
                setError("Character data is missing.");
                setIsLoading(false);
                return;
            }

            setIsLoading(true);
            setError(null);
            try {
                const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
                const questTexts = questItems.map(q => `- ${q.text}`).join('\n') || 'None';
                const inboxTexts = inboxItems.map(i => `- ${i.text}`).join('\n') || 'None';

                const response = await ai.models.generateContent({
                    model: "gemini-2.5-flash",
                    contents: `You are a scriptwriter for a productivity app. Write a short "Huddle" dialogue between two characters: Sonia and Sister Mary Samuel.

                    Sonia (${sonia.title}) should identify a practical problem or point of friction based on the user's current tasks.
                    Sister Mary Samuel (${sisterMary.title}) should then provide a gentle, motivational reframing of that problem.

                    USER'S CURRENT CONTEXT:
                    Quests:
                    ${questTexts}

                    Inbox Items:
                    ${inboxTexts}

                    Your response must be a single JSON object.`,
                    config: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: Type.OBJECT,
                            properties: {
                                sonia_dialogue: { type: Type.STRING, description: "Sonia's practical observation." },
                                sister_mary_dialogue: { type: Type.STRING, description: "Sister Mary's motivational reframing." }
                            },
                            required: ["sonia_dialogue", "sister_mary_dialogue"]
                        },
                    },
                });
                
                setDialogue(JSON.parse(response.text));

            } catch (e) {
                console.error("Failed to generate huddle dialogue:", e);
                setError("The team is having trouble connecting at the moment. Please try again.");
                setDialogue({
                    sonia_dialogue: "It seems we have a lot on our plate, and it's difficult to see where to start.",
                    sister_mary_dialogue: "And what a wonderful challenge! Each task is just an opportunity to take one small, faithful step forward."
                });
            } finally {
                setIsLoading(false);
            }
        };

        generateDialogue();
    }, [questItems, inboxItems, sonia, sisterMary]);

    return (
        <div className="fixed inset-0 bg-slate-900/40 z-50 flex items-center justify-center p-4 backdrop-blur-lg animate-fade-in" onClick={onClose}>
            <div className="relative bg-white/80 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-2xl p-8 transform transition-all animate-fade-in-up" onClick={e => e.stopPropagation()}>
                <h2 className="text-3xl font-bold text-slate-800 font-serif text-center mb-6">Team Huddle</h2>
                
                {isLoading && (
                    <div className="flex flex-col items-center min-h-[200px] justify-center">
                        <div className="w-8 h-8 border-4 border-slate-300 border-t-slate-600 rounded-full animate-spin"></div>
                        <p className="text-slate-600 font-semibold mt-4">The team is gathering...</p>
                    </div>
                )}
                {error && <p className="text-red-500 text-center font-semibold min-h-[200px]">{error}</p>}
                
                {dialogue && !isLoading && (
                    <div className="space-y-6 animate-fade-in">
                        {/* Sonia's Dialogue */}
                        <div className="flex items-start gap-4">
                            <div className="w-16 h-16 rounded-full bg-sky-400 p-1 flex-shrink-0 shadow-lg"><SoniaAvatar /></div>
                            <div>
                                <p className="font-bold text-slate-700">{sonia?.name || 'Sonia'}</p>
                                <div className="mt-1 p-3 bg-white/70 rounded-lg rounded-tl-none border border-white/50">
                                    <p className="text-slate-800">{dialogue.sonia_dialogue}</p>
                                </div>
                            </div>
                        </div>

                        {/* Sister Mary's Dialogue */}
                        <div className="flex items-start gap-4">
                             <div className="w-16 h-16 rounded-full bg-slate-400 p-1 flex-shrink-0 shadow-lg"><SisterMaryAvatar /></div>
                            <div>
                                <p className="font-bold text-slate-700">{sisterMary?.name || 'Sister Mary Samuel'}</p>
                                <div className="mt-1 p-3 bg-white/70 rounded-lg rounded-tl-none border border-white/50">
                                    <p className="text-slate-800 italic">{dialogue.sister_mary_dialogue}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                )}
                
                <div className="text-center mt-8">
                    <button onClick={onClose} className="px-8 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md">
                        Got it. Let's go.
                    </button>
                </div>
            </div>
        </div>
    );
};
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { TimeBlock, Recurrence, CapturedItem } from '../hooks/types';
import { TIME_BLOCK_COLORS } from '../constants';

interface TimeWeavingLoomProps {
    blocks: TimeBlock[];
    setBlocks: React.Dispatch<React.SetStateAction<TimeBlock[]>>;
    questItems: CapturedItem[];
}

const HOURS = Array.from({ length: 24 }, (_, i) => i);
const HOUR_HEIGHT = 50; // pixels
const SNAP_INCREMENT = 0.5; // Snap to half-hour

export const TimeWeavingLoom: React.FC<TimeWeavingLoomProps> = ({ blocks, setBlocks, questItems }) => {
    const [now, setNow] = useState(new Date());
    const [editingBlock, setEditingBlock] = useState<Partial<TimeBlock> | null>(null);
    const [interaction, setInteraction] = useState<{ type: 'move' | 'resize'; blockId: string; initialY: number; initialStart: number; initialDuration: number; } | null>(null);
    const loomRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        const timerId = setInterval(() => setNow(new Date()), 60000); // Update every minute
        return () => clearInterval(timerId);
    }, []);

    useEffect(() => {
        if (editingBlock) {
            inputRef.current?.focus();
        }
    }, [editingBlock]);

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (!interaction || !loomRef.current) return;

        const loomRect = loomRef.current.getBoundingClientRect();
        const deltaY = e.clientY - interaction.initialY;
        const deltaHours = deltaY / HOUR_HEIGHT;

        setBlocks(prevBlocks => prevBlocks.map(block => {
            if (block.id !== interaction.blockId) return block;
            
            let newStart = block.startHour;
            let newDuration = block.duration;

            if (interaction.type === 'move') {
                newStart = interaction.initialStart + deltaHours;
            } else { // resize
                newDuration = interaction.initialDuration + deltaHours;
            }

            // Snap to grid and apply constraints
            newStart = Math.max(0, Math.round(newStart / SNAP_INCREMENT) * SNAP_INCREMENT);
            newDuration = Math.max(SNAP_INCREMENT, Math.round(newDuration / SNAP_INCREMENT) * SNAP_INCREMENT);
            if (newStart + newDuration > 24) {
                 if(interaction.type === 'move') {
                    newStart = 24 - newDuration;
                 } else {
                    newDuration = 24 - newStart;
                 }
            }
            
            return { ...block, startHour: newStart, duration: newDuration };
        }));

    }, [interaction, setBlocks]);

    const handleMouseUp = useCallback(() => {
    if (!interaction) return;

    // 1. Stop Dragging: Set the interaction state to null
    setInteraction(null);

    // 2. Clean Up: REMOVE the global event listeners
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
}, [interaction, handleMouseMove]); 
// NOTE: handleMouseMove dependency ensures the correct handler instance is removed

    const handleBlockMouseDown = (e: React.MouseEvent, block: TimeBlock, type: 'move' | 'resize') => {
        e.stopPropagation();
        setInteraction({
            type,
            blockId: block.id,
            initialY: e.clientY,
            initialStart: block.startHour,
            initialDuration: block.duration,
        });
document.addEventListener('mousemove', handleMouseMove);
document.addEventListener('mouseup', handleMouseUp);    };
    
    const handleLoomClick = (e: React.MouseEvent) => {
        if (!loomRef.current || editingBlock) return;
        const rect = loomRef.current.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const hour = Math.floor(y / HOUR_HEIGHT / SNAP_INCREMENT) * SNAP_INCREMENT;
        setEditingBlock({ startHour: hour, duration: 1, title: '', color: 'Default', recurring: 'none' });
    };

    const handleSaveBlock = () => {
        if (!editingBlock || !editingBlock.title) {
            setEditingBlock(null);
            return;
        }
        
        const newBlock: TimeBlock = {
            id: editingBlock.id || uuidv4(),
            title: editingBlock.title,
            startHour: editingBlock.startHour!,
            duration: editingBlock.duration!,
            color: editingBlock.color || 'Default',
            recurring: editingBlock.recurring || 'none',
            questId: editingBlock.questId,
        };

        if(editingBlock.id) { // update existing
            setBlocks(blocks.map(b => b.id === newBlock.id ? newBlock : b));
        } else { // create new
            setBlocks([...blocks, newBlock]);
        }
        setEditingBlock(null);
    };
    
    const handleDeleteBlock = (id: string) => {
        setBlocks(blocks.filter(b => b.id !== id));
        setEditingBlock(null);
    }
    
    const currentTimePosition = (now.getHours() + now.getMinutes() / 60) * HOUR_HEIGHT;

    const getBlockColorClasses = (colorName: string) => {
        const color = TIME_BLOCK_COLORS.find(c => c.name === colorName) || TIME_BLOCK_COLORS[0];
        return { bg: color.bg, border: color.border };
    };

    const scheduledQuestIds = new Set(blocks.map(b => b.questId).filter(Boolean));
    const availableQuests = questItems.filter(q => !scheduledQuestIds.has(q.id) || q.id === editingBlock?.questId);


    return (
        <div className="w-full h-full bg-slate-800/80 backdrop-blur-md rounded-2xl shadow-2xl p-4 flex flex-col font-sans overflow-hidden">
            <h2 className="text-2xl font-bold text-white font-serif text-center mb-2">Time-Weaving Loom</h2>
            <div className="flex-grow w-full flex gap-4 overflow-hidden">
                {/* Hour Gutter */}
                <div className="flex-shrink-0 h-full overflow-y-auto custom-scrollbar pr-2">
                    {HOURS.map(hour => (
                        <div key={hour} className="text-right h-[50px] text-xs text-slate-400 pr-2 border-r border-slate-600">
                            {hour === 0 ? '12 AM' : hour < 12 ? `${hour} AM` : hour === 12 ? '12 PM' : `${hour - 12} PM`}
                        </div>
                    ))}
                </div>

                {/* Loom Timeline */}
                <div 
                    ref={loomRef} 
                    className="relative flex-grow h-full bg-slate-900/50 rounded-lg overflow-y-auto custom-scrollbar"
                    onClick={handleLoomClick}
                >
                    {HOURS.map(hour => (
                        <div key={hour} className="h-[50px] border-b border-slate-700/50"></div>
                    ))}

                    <div 
                        className="absolute top-0 left-0 w-full h-px bg-yellow-300 shadow-[0_0_10px_theme(colors.yellow.300)]"
                        style={{ transform: `translateY(${currentTimePosition}px)`}}
                    >
                        <div className="absolute -left-2 -top-1.5 w-2 h-2 rounded-full bg-yellow-300"></div>
                    </div>
                    
                    {blocks.map(block => {
                        const { bg, border } = getBlockColorClasses(block.color);
                        return (
                             <div 
                                key={block.id}
                                title={block.title}
                                className={`absolute w-[calc(100%-8px)] left-1 p-2 ${bg} ${border} rounded-md cursor-grab text-white flex flex-col justify-between`}
                                style={{
                                    top: `${block.startHour * HOUR_HEIGHT}px`,
                                    height: `${block.duration * HOUR_HEIGHT}px`,
                                    minHeight: `${SNAP_INCREMENT * HOUR_HEIGHT}px`,
                                }}
                                onMouseDown={(e) => handleBlockMouseDown(e, block, 'move')}
                                onClick={(e) => { e.stopPropagation(); setEditingBlock(block); }}
                            >
                                <div className="flex justify-between items-start">
                                    <p className="text-sm font-semibold truncate pr-2">{block.title}</p>
                                    <div className="flex-shrink-0 flex items-center gap-1">
                                        {block.questId && <span className="text-base" title="This is a scheduled Quest">üó∫Ô∏è</span>}
                                        {block.recurring !== 'none' && (
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-white/70 animate-[spin-slow_5s_linear_infinite]" viewBox="0 0 20 20" fill="currentColor">
                                                <title>{`Repeats ${block.recurring}`}</title>
                                                <path fillRule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 110 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clipRule="evenodd" />
                                            </svg>
                                        )}
                                    </div>
                                </div>
                                <div 
                                    className="absolute bottom-0 left-0 w-full h-2 cursor-ns-resize"
                                    onMouseDown={(e) => handleBlockMouseDown(e, block, 'resize')}
                                />
                            </div>
                        )
                    })}

                    {editingBlock && (
                        <div 
                            className="absolute w-[calc(100%-8px)] left-1 p-3 bg-white/95 rounded-lg shadow-2xl animate-fade-in"
                             style={{
                                top: `${editingBlock.startHour! * HOUR_HEIGHT}px`,
                                zIndex: 10,
                            }}
                            onClick={e => e.stopPropagation()}
                        >
                            <div className="mb-3">
                                <label className="text-sm font-medium text-slate-600">Link to Quest</label>
                                <select
                                    value={editingBlock.questId || ''}
                                    onChange={(e) => {
                                        const selectedQuestId = e.target.value;
                                        const selectedQuest = questItems.find(q => q.id === selectedQuestId);
                                        setEditingBlock(b => ({
                                            ...b!,
                                            questId: selectedQuest ? selectedQuest.id : undefined,
                                            title: selectedQuest ? selectedQuest.text : '', // Clear title when unlinking
                                        }));
                                    }}
                                    className="w-full p-2 mt-1 border rounded text-slate-800 bg-white"
                                >
                                    <option value="">-- No linked quest --</option>
                                    {availableQuests.map(q => (
                                        <option key={q.id} value={q.id}>{q.text}</option>
                                    ))}
                                </select>
                            </div>

                            <input 
                                ref={inputRef}
                                type="text" 
                                value={editingBlock.title}
                                onChange={e => setEditingBlock(b => ({...b!, title: e.target.value}))}
                                placeholder="Or enter a custom title"
                                className="w-full p-2 mb-3 border rounded text-slate-800 disabled:bg-slate-200/50"
                                disabled={!!editingBlock.questId}
                            />
                            
                            <div className="mb-3">
                                <label className="text-sm font-medium text-slate-600">Color</label>
                                <div className="flex gap-2 mt-1">
                                    {TIME_BLOCK_COLORS.map(color => (
                                        <button 
                                            key={color.name} 
                                            title={color.name}
                                            onClick={() => setEditingBlock(b => ({...b!, color: color.name}))}
                                            className={`w-6 h-6 rounded-full ${color.bg.replace('/80', '')} ${editingBlock.color === color.name ? 'ring-2 ring-offset-1 ring-indigo-500' : ''}`}
                                        />
                                    ))}
                                </div>
                            </div>

                            <div className="mb-3">
                                <label className="text-sm font-medium text-slate-600">Repeats</label>
                                <div className="flex gap-4 mt-1 text-sm text-slate-700">
                                    {(['none', 'daily', 'weekly'] as Recurrence[]).map(r => (
                                        <label key={r} className="flex items-center gap-1 cursor-pointer">
                                            <input type="radio" name="recurrence" value={r} checked={editingBlock.recurring === r} onChange={() => setEditingBlock(b => ({...b!, recurring: r}))} className="text-indigo-500 focus:ring-indigo-400"/>
                                            <span className="capitalize">{r}</span>
                                        </label>
                                    ))}
                                </div>
                            </div>
                            
                            <div className="flex items-center mb-2">
                                <label className="text-sm mr-2 text-slate-600">Duration (hrs):</label>
                                <input 
                                    type="number"
                                    step="0.5"
                                    min="0.5"
                                    max="24"
                                    value={editingBlock.duration}
                                    onChange={e => setEditingBlock(b => ({...b!, duration: parseFloat(e.target.value)}))}
                                    className="w-20 p-1 border rounded text-slate-800"
                                />
                            </div>
                            <div className="flex justify-between mt-4 border-t pt-3">
                                 <button onClick={() => handleDeleteBlock(editingBlock.id!)} className="text-sm text-red-600 hover:text-red-800 disabled:text-slate-400" disabled={!editingBlock.id} title="Delete this block">
                                    Delete
                                </button>
                                <div>
                                    <button onClick={() => setEditingBlock(null)} className="text-sm px-3 py-1 mr-2 bg-slate-200 rounded">Cancel</button>
                                    <button onClick={handleSaveBlock} className="text-sm px-3 py-1 bg-indigo-500 text-white rounded">Save</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};
import React, { useState, useEffect } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import { SoniaAvatar } from './CharacterAvatars';

interface TransitionRitualProps {
    onComplete: () => void;
}

export const TransitionRitual: React.FC<TransitionRitualProps> = ({ onComplete }) => {
    const [steps, setSteps] = useState<string[] | null>(null);
    const [currentStep, setCurrentStep] = useState(0);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const generateRitual = async () => {
            setIsLoading(true);
            setError(null);
            try {
                if (!process.env.API_KEY) {
                    throw new Error("API key not configured.");
                }

                const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
                const prompt = `You are Sonia, an ADHD coach and Chief of Staff. A user just finished a task. Provide a simple, 2-step transition ritual to help them reset and detach before the next task. The steps should be physical, brief, and mindful. Format the response as a JSON array of 2 strings. Example: ["Take 3 deep, slow breaths.", "Gently stretch your neck from side to side."]`
                
                const response = await ai.models.generateContent({
                    model: 'gemini-2.5-flash',
                    contents: prompt,
                    config: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: Type.ARRAY,
                            items: { type: Type.STRING },
                            minItems: 2,
                            maxItems: 2,
                        }
                    }
                });

                setSteps(JSON.parse(response.text));
            } catch (e) {
                console.error("Failed to generate ritual:", e);
                setError("Sonia is having a little trouble. Let's just take a deep breath.");
                // Fallback ritual
                setSteps(["Take one deep, cleansing breath.", "Stand up and stretch your arms to the sky."]);
            } finally {
                setIsLoading(false);
            }
        };

        generateRitual();
    }, []);

    const handleNextStep = () => {
        if (steps && currentStep < steps.length - 1) {
            setCurrentStep(currentStep + 1);
        } else {
            onComplete();
        }
    };

    const renderContent = () => {
        if (isLoading) {
            return (
                <div className="flex flex-col items-center">
                    <div className="w-8 h-8 border-4 border-slate-300 border-t-slate-600 rounded-full animate-spin mb-4"></div>
                    <p className="text-slate-600 font-semibold">Sonia is preparing your ritual...</p>
                </div>
            );
        }
        
        if (error && !steps) {
            return <p className="text-red-500 text-center font-semibold">{error}</p>
        }
        
        if (steps) {
            const stepText = steps[currentStep];
            const isLastStep = currentStep === steps.length - 1;
            return (
                <div className="animate-fade-in w-full">
                    <p className="font-semibold text-slate-500 text-sm uppercase tracking-wider mb-4">Step {currentStep + 1} of {steps.length}</p>
                    <p className="text-3xl font-serif text-slate-800 leading-snug">{stepText}</p>
                     <button
                        onClick={handleNextStep}
                        className="mt-12 px-10 py-3 bg-gradient-to-br from-sky-500 to-blue-600 text-white font-semibold rounded-lg shadow-lg shadow-sky-500/30 hover:from-sky-600 hover:to-blue-700 transition-all"
                    >
                        {isLastStep ? "Finish Ritual" : "Next Step"}
                    </button>
                </div>
            );
        }
        
        return null;
    }

    return (
        <div className="fixed inset-0 bg-slate-900/40 z-50 flex items-center justify-center p-4 backdrop-blur-lg animate-fade-in">
            <div className="relative bg-white/80 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-lg p-8 text-center transform transition-all animate-fade-in-up flex flex-col items-center">
                <div className="w-24 h-24 sm:w-32 sm:h-32 rounded-full bg-sky-400 p-2 flex-shrink-0 shadow-lg mb-6">
                    <SoniaAvatar />
                </div>
                <h2 className="text-3xl font-bold text-slate-800 font-serif mb-4">Transition Ritual</h2>
                <p className="text-lg text-slate-600 mb-8">A brief pause to reset your focus.</p>

                <div className="min-h-[150px] flex items-center justify-center w-full">
                    {renderContent()}
                </div>
            </div>
        </div>
    );
};
import React, { useState } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CapturedItem, CharacterData } from '../hooks/types';

interface TrophyRoomProps {
    completedQuests: CapturedItem[];
    character: CharacterData;
}

export const TrophyRoom: React.FC<TrophyRoomProps> = ({ completedQuests, character }) => {
    const [cheers, setCheers] = useState<Record<string, { loading: boolean; message: string | null }>>({});

    const handleGetCheer = async (quest: CapturedItem) => {
        setCheers(prev => ({ ...prev, [quest.id]: { loading: true, message: null } }));
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const prompt = `You are Pep, the Chief Morale Officer, a glorious, over-the-top explosion of color and pure enthusiasm. The user just completed this quest: "${quest.text}". Write a short, punchy, over-the-top enthusiastic pep talk specifically for this accomplishment! Use lots of exclamation points and emojis. Keep it under 50 words. üéâ`;
            
            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: prompt,
            });

            setCheers(prev => ({ ...prev, [quest.id]: { loading: false, message: response.text } }));
        } catch (e) {
            console.error(e);
            setCheers(prev => ({ ...prev, [quest.id]: { loading: false, message: "My pom-poms are tangled! Try again in a moment." } }));
        }
    };
    
    return (
        <div className="mt-8 p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans">
             <div className="flex items-center gap-3 mb-4 px-2 sm:px-0">
                <span className="text-3xl" aria-hidden="true">üèÜ</span>
                <h2 id="trophy-room-heading" className="text-2xl font-bold text-slate-700 font-serif">Trophy Shelf</h2>
            </div>
            <p className="text-slate-600 text-sm mb-4 text-center">Click on a trophy to get a personalized cheer from Pep!</p>

            <div role="list" aria-labelledby="trophy-room-heading" className="max-h-96 overflow-y-auto pr-2 space-y-3 custom-scrollbar">
                {completedQuests.length > 0 ? (
                    completedQuests.map((quest, index) => (
                        <div 
                            key={quest.id} 
                            role="listitem" 
                            className="bg-stone-100 p-3 rounded-lg shadow-sm border border-stone-200/50 animate-fade-in-up"
                            style={{ animationDelay: `${index * 50}ms`}}
                        >
                            <button 
                                onClick={() => handleGetCheer(quest)}
                                disabled={cheers[quest.id]?.loading}
                                className="w-full flex items-center text-left group transition-transform duration-200 hover:scale-[1.02]"
                            >
                                <span className="text-2xl mr-4 group-hover:animate-bounce" aria-hidden="true">üèÖ</span>
                                <p className="text-stone-900 flex-grow">{quest.text}</p>
                                <span className="text-pink-500 font-bold text-sm ml-2 opacity-0 group-hover:opacity-100 transition-opacity">Get Cheer!</span>
                            </button>
                             {cheers[quest.id]?.loading && (
                                <div className="text-center text-sm text-slate-500 mt-2">Pep is warming up...</div>
                            )}
                            {cheers[quest.id]?.message && (
                                <div className="mt-3 pt-3 border-t border-pink-200/50">
                                    <div className="p-3 bg-white/80 border border-pink-200 rounded-lg text-pink-800 animate-fade-in">
                                        <p className="font-medium">{cheers[quest.id]?.message}</p>
                                    </div>
                                </div>
                            )}
                        </div>
                    ))
                ) : (
                     <div className="text-center py-8 px-4">
                        <span className="text-4xl">‚ú®</span>
                        <p className="mt-3 font-semibold text-slate-600">Your First Trophy Awaits!</p>
                        <p className="text-slate-500 text-sm">Complete a quest in the Quest Log to earn a trophy.</p>
                    </div>
                )}
            </div>
        </div>
    );
};

import { useState, useEffect } from 'react';
import { TimeOfDay } from '../hooks/types';

export const useTimeOfDay = (): TimeOfDay => {
  const [timeOfDay, setTimeOfDay] = useState<TimeOfDay>(() => getTimeOfDay());

  function getTimeOfDay(): TimeOfDay {
    const hour = new Date().getHours();
    if (hour >= 6 && hour < 18) {
      return 'day';
    } else if (hour >= 18 && hour < 20) {
      return 'dusk';
    } else {
      return 'night';
    }
  }

  useEffect(() => {
    const interval = setInterval(() => {
      setTimeOfDay(getTimeOfDay());
    }, 60000); // Update every minute

    return () => clearInterval(interval);
  }, []);

  return timeOfDay;
};
import React, { useState } from 'react';
import { GoogleGenAI } from "@google/genai";
import { CapturedItem } from '../hooks/types';

interface ValuesPrioritizationProps {
    userValues: string[];
    onSetUserValues: (values: string[]) => void;
    questItems: CapturedItem[];
}

export const ValuesPrioritization: React.FC<ValuesPrioritizationProps> = ({ userValues, onSetUserValues, questItems }) => {
    const [inputValue, setInputValue] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [suggestion, setSuggestion] = useState<string | null>(null);

    const handleAddValue = (e: React.FormEvent) => {
        e.preventDefault();
        if (inputValue && !userValues.includes(inputValue)) {
            onSetUserValues([...userValues, inputValue]);
            setInputValue('');
        }
    };

    const handleRemoveValue = (valueToRemove: string) => {
        onSetUserValues(userValues.filter(value => value !== valueToRemove));
    };

    const handleGetSuggestion = async () => {
        if (userValues.length === 0 || questItems.length === 0) return;
        setIsLoading(true);
        setSuggestion(null);
        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
            const prompt = `You are Sonia, a hyper-competent Chief of Staff. Based on the user's core values and their current quest log, suggest the single most important quest to focus on next and briefly explain why it aligns with their values.

Core Values:
${userValues.join(', ')}

Quest Log:
${questItems.map(q => `- ${q.text}`).join('\n')}

Respond with the suggested quest text first, followed by a colon, and then your brief reasoning. For example: "Suggested Quest: Your reasoning here."`;
            
            const response = await ai.models.generateContent({ model: 'gemini-2.5-flash', contents: prompt });
            setSuggestion(response.text);

        } catch (e) {
            console.error(e);
            setSuggestion("I had trouble analyzing the quests. Please try again.");
        } finally {
            setIsLoading(false);
        }
    }

    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center gap-3 mb-2">
                <span className="text-3xl" aria-hidden="true">üß≠</span>
                <h2 className="text-2xl font-bold text-slate-700 font-serif">Values-Based Prioritization</h2>
            </div>
            <p className="text-slate-600 mb-4 text-sm">Define what's important to you, then let Sonia help you focus.</p>

            <div className="mb-4">
                <form onSubmit={handleAddValue} className="flex gap-2">
                    <input 
                        type="text"
                        value={inputValue}
                        onChange={e => setInputValue(e.target.value)}
                        placeholder="Add a core value (e.g., Creativity)"
                        className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner"
                    />
                    <button type="submit" className="px-4 py-2 bg-slate-700 text-white font-semibold rounded-md hover:bg-slate-800 transition-colors">Add</button>
                </form>
                <div className="mt-2 flex flex-wrap gap-2">
                    {userValues.map(value => (
                        <div key={value} className="bg-slate-200/70 text-slate-800 text-sm font-medium px-3 py-1 rounded-full flex items-center gap-2">
                            <span>{value}</span>
                            <button onClick={() => handleRemoveValue(value)} className="text-slate-600 hover:text-slate-800">&times;</button>
                        </div>
                    ))}
                </div>
            </div>

            {userValues.length > 0 && questItems.length > 0 && (
                 <div className="text-center mt-4 p-4 bg-stone-100/50 rounded-lg border border-stone-200/50">
                    <button onClick={handleGetSuggestion} disabled={isLoading} className="px-6 py-2 bg-slate-700 text-white font-semibold rounded-full shadow-md hover:bg-slate-800 transition-all disabled:bg-slate-400 disabled:shadow-none disabled:cursor-not-allowed">
                        {isLoading ? "Analyzing..." : "Ask Sonia for Priority Advice"}
                    </button>
                    {suggestion && (
                        <div className="mt-4 p-3 bg-white/80 border border-slate-200 rounded-lg text-slate-900 animate-fade-in text-left">
                            <p className="font-semibold">Sonia's Suggestion:</p>
                            <p>{suggestion}</p>
                        </div>
                    )}
                </div>
            )}
        </div>
    );
};
import React, { useState, useEffect, useRef } from 'react';
import { GoogleGenAI, FunctionDeclaration, Type, Modality, Blob, LiveServerMessage } from '@google/genai';
import { CharacterData, HubId } from '../hooks/types';

// A local interface to represent the LiveSession object.
interface LiveSession {
  sendRealtimeInput(input: { media: Blob }): void;
  sendToolResponse(response: { functionResponses: { id: string; name: string; response: { result: string; } } }): void;
  close(): void;
}

// Audio helper functions
const encode = (bytes: Uint8Array) => btoa(Array.from(bytes).map(byte => String.fromCharCode(byte)).join(''));
const decode = (base64: string) => Uint8Array.from(atob(base64), c => c.charCodeAt(0));

async function decodeAudioData(data: Uint8Array, ctx: AudioContext, sampleRate: number, numChannels: number): Promise<AudioBuffer> {
    const dataInt16 = new Int16Array(data.buffer);
    const frameCount = dataInt16.length / numChannels;
    const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);
    for (let channel = 0; channel < numChannels; channel++) {
        const channelData = buffer.getChannelData(channel);
        for (let i = 0; i < frameCount; i++) {
            channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
        }
    }
    return buffer;
}

const createBlob = (data: Float32Array): Blob => ({
    data: encode(new Uint8Array(new Int16Array(data.map(v => v * 32768)).buffer)),
    mimeType: 'audio/pcm;rate=16000',
});

const getVoiceForCharacter = (characterId: HubId): string => {
    switch (characterId) {
        case HubId.Jake: return 'Charon'; // Deep, masculine voice
        case HubId.FiNancy: return 'Puck'; // Friendly, lighter voice
        case HubId.Sonia: return 'Zephyr'; // Professional, clear female voice
        case HubId.Pep: return 'Kore';   // Energetic, youthful female voice
        case HubId.SisterMary: return 'Zephyr'; // Warm, calm female voice
        default: return 'Zephyr';
    }
};

interface VoiceChatInterfaceProps {
    character: CharacterData;
    onClose: () => void;
}

interface ChatMessage {
    speaker: 'user' | 'model';
    text: string;
}

type SessionStatus = 'IDLE' | 'CONNECTING' | 'LISTENING' | 'SPEAKING' | 'ENDED' | 'ERROR';

export const VoiceChatInterface: React.FC<VoiceChatInterfaceProps> = ({ character, onClose }) => {
    const [status, setStatus] = useState<SessionStatus>('IDLE');
    const [transcript, setTranscript] = useState<ChatMessage[]>([]);
    const [currentInput, setCurrentInput] = useState('');
    const [currentOutput, setCurrentOutput] = useState('');

    const sessionPromiseRef = useRef<Promise<LiveSession> | null>(null);
    const audioResourcesRef = useRef<{
        inputCtx?: AudioContext;
        outputCtx?: AudioContext;
        stream?: MediaStream;
        source?: MediaStreamAudioSourceNode;
        processor?: ScriptProcessorNode;
        playingSources: Set<AudioBufferSourceNode>;
        nextStartTime: number;
    }>({ playingSources: new Set(), nextStartTime: 0 });
    const messagesEndRef = useRef<HTMLDivElement>(null);

    const closeHubFunction: FunctionDeclaration = {
        name: 'closeHub',
        parameters: { type: Type.OBJECT, description: 'Closes the current character hub view and returns to the main lounge screen.', properties: {} },
    };

    const startSession = async () => {
        if (!process.env.API_KEY) {
            console.error("API_KEY not set.");
            setStatus('ERROR');
            return;
        }

        setStatus('CONNECTING');
        setTranscript([{ speaker: 'model', text: character.introDialogue }]);
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });
        const audio = audioResourcesRef.current;

        try {
            audio.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            setStatus('LISTENING');
            
            const voiceName = getVoiceForCharacter(character.id);

            sessionPromiseRef.current = ai.live.connect({
                model: 'gemini-2.5-flash-native-audio-preview-09-2025',
                config: {
                    responseModalities: [Modality.AUDIO],
                    tools: [{ functionDeclarations: [closeHubFunction] }],
                    systemInstruction: `${character.basePrompt}. You are in a voice conversation. Be concise. If the user says "go back" or "return to lounge", call the closeHub function.`,
                    outputAudioTranscription: {},
                    inputAudioTranscription: {},
                    speechConfig: {
                        voiceConfig: { prebuiltVoiceConfig: { voiceName } },
                    },
                },
                callbacks: {
                    onopen: () => {
                        audio.inputCtx = new AudioContext({ sampleRate: 16000 });
                        audio.outputCtx = new AudioContext({ sampleRate: 24000 });
                        audio.source = audio.inputCtx.createMediaStreamSource(audio.stream!);
                        audio.processor = audio.inputCtx.createScriptProcessor(4096, 1, 1);
                        audio.processor.onaudioprocess = (e) => {
                            const inputData = e.inputBuffer.getChannelData(0);
                            sessionPromiseRef.current?.then(s => s.sendRealtimeInput({ media: createBlob(inputData) }));
                        };
                        audio.source.connect(audio.processor);
                        audio.processor.connect(audio.inputCtx.destination);
                    },
                    onmessage: async (msg: LiveServerMessage) => {
                        if (msg.toolCall?.functionCalls[0]?.name === 'closeHub') { onClose(); }
                        
                        if (msg.serverContent?.inputTranscription) setCurrentInput(t => t + msg.serverContent!.inputTranscription!.text);
                        if (msg.serverContent?.outputTranscription) setCurrentOutput(t => t + msg.serverContent!.outputTranscription!.text);
                        
                        if (msg.serverContent?.turnComplete) {
                            setTranscript(prev => [...prev, { speaker: 'user', text: currentInput }, { speaker: 'model', text: currentOutput }]);
                            setCurrentInput('');
                            setCurrentOutput('');
                        }
                        
                        const audioData = msg.serverContent?.modelTurn?.parts[0]?.inlineData.data;
                        if (audioData && audio.outputCtx) {
                            setStatus('SPEAKING');
                            audio.nextStartTime = Math.max(audio.nextStartTime, audio.outputCtx.currentTime);
                            const buffer = await decodeAudioData(decode(audioData), audio.outputCtx, 24000, 1);
                            const sourceNode = audio.outputCtx.createBufferSource();
                            sourceNode.buffer = buffer;
                            sourceNode.connect(audio.outputCtx.destination);
                            sourceNode.onended = () => {
                                audio.playingSources.delete(sourceNode);
                                if (audio.playingSources.size === 0) setStatus('LISTENING');
                            };
                            sourceNode.start(audio.nextStartTime);
                            audio.nextStartTime += buffer.duration;
                            audio.playingSources.add(sourceNode);
                        }
                    },
                    onerror: (e) => { console.error('Voice session error:', e); setStatus('ERROR'); },
                    onclose: () => { setStatus('ENDED'); },
                },
            });
            sessionPromiseRef.current.catch(err => { console.error("Session promise rejected:", err); setStatus('ERROR'); });
        } catch (err) {
            console.error('Error starting voice session:', err);
            setStatus('ERROR');
        }
    };

    const stopSession = () => {
        sessionPromiseRef.current?.then(s => s.close()).catch(console.error);
        const audio = audioResourcesRef.current;
        audio.stream?.getTracks().forEach(track => track.stop());
        audio.processor?.disconnect();
        audio.source?.disconnect();
        audio.inputCtx?.close().catch(console.error);
        audio.outputCtx?.close().catch(console.error);
        audio.playingSources.forEach(s => s.stop());
        Object.assign(audio, { stream: undefined, processor: undefined, source: undefined, inputCtx: undefined, outputCtx: undefined, playingSources: new Set(), nextStartTime: 0 });
        sessionPromiseRef.current = null;
        setStatus('ENDED');
    };
    
    const handleEndAndClose = () => {
        stopSession();
        onClose();
    };

    useEffect(() => {
        startSession();
        return () => { stopSession(); };
    }, [character.id]);

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [transcript, currentInput, currentOutput]);

    const Avatar = typeof character.avatar === 'string' ? <img src={character.avatar} alt={character.name} className="w-full h-full object-cover rounded-full" /> : <character.avatar className="w-full h-full" />;

    return (
        <div className="mt-8 p-1 sm:p-2 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans flex flex-col max-h-[65vh]">
            <div className="flex-grow p-4 space-y-4 overflow-y-auto custom-scrollbar">
                {transcript.map((msg, index) => (
                    <div key={index} className={`flex items-end gap-3 ${msg.speaker === 'user' ? 'justify-end' : 'justify-start'}`}>
                        {msg.speaker === 'model' && <div className="w-10 h-10 rounded-full flex-shrink-0 shadow-md">{Avatar}</div>}
                        <div className={`max-w-xs md:max-w-md p-3 rounded-2xl ${msg.speaker === 'user' ? 'bg-indigo-500 text-white rounded-br-none' : 'bg-white/80 text-slate-800 rounded-bl-none shadow-sm'}`}>
                            <p>{msg.text}</p>
                        </div>
                    </div>
                ))}
                {currentInput && <div className="text-right italic text-slate-500">{currentInput}</div>}
                {currentOutput && <div className="text-left italic text-slate-500">{currentOutput}</div>}
                <div ref={messagesEndRef} />
            </div>
            <div className="flex-shrink-0 p-3 border-t border-white/50 flex justify-between items-center">
                <div className="text-sm font-semibold text-slate-700">
                    {status === 'LISTENING' && <span className="flex items-center gap-2"><div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>Listening...</span>}
                    {status === 'SPEAKING' && <span className="flex items-center gap-2"><div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>Speaking...</span>}
                    {status === 'CONNECTING' && <span>Connecting...</span>}
                    {status === 'ENDED' && <span>Session Ended.</span>}
                    {status === 'ERROR' && <span className="text-red-500">Connection Error.</span>}
                </div>
                <button onClick={handleEndAndClose} disabled={status === 'ENDED' || status === 'IDLE'} className="px-4 py-2 bg-rose-600 hover:bg-rose-700 text-white font-semibold rounded-lg shadow-md disabled:bg-slate-400">End Conversation</button>
            </div>
        </div>
    );
};
import React, { useState } from 'react';

interface WeeklyReviewProps {
    onFinish: () => void;
}

const reviewSteps = [
    {
        title: "Clear Your Head",
        emoji: "üß†",
        prompt: "First, let's get everything out of your head. What's been on your mind? Any new ideas, worries, or to-dos? Don't filter, just capture.",
        action: "I've captured everything"
    },
    {
        title: "Process Your Inboxes",
        emoji: "üì•",
        prompt: "Now, look at your inboxes (email, physical mail, voicemails, and your Omni-Inbox here). Process each item to empty. Does it require action? Can it be delegated, deferred, or deleted?",
        action: "Inboxes are clear"
    },
    {
        title: "Review Your Quests",
        emoji: "üó∫Ô∏è",
        prompt: "Take a look at your current Quest Log. Are these still the right things to be working on? Do any need to be broken down further or rescheduled?",
        action: "Quests reviewed"
    },
    {
        title: "Look Ahead",
        emoji: "üóìÔ∏è",
        prompt: "Finally, check your calendar for the upcoming week. Are there any appointments or events you need to prepare for? Block out time for your important quests.",
        action: "I'm ready for the week"
    }
];

export const WeeklyReview: React.FC<WeeklyReviewProps> = ({ onFinish }) => {
    const [currentStep, setCurrentStep] = useState(0);
    const step = reviewSteps[currentStep];

    const handleNext = () => {
        if (currentStep < reviewSteps.length - 1) {
            setCurrentStep(currentStep + 1);
        } else {
            onFinish();
        }
    };

    return (
        <div className="p-4 sm:p-8 bg-white/60 backdrop-blur-lg rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans text-center">
            <div className="mb-6">
                <span className="text-5xl">{step.emoji}</span>
                <h2 className="text-3xl font-bold text-slate-800 font-serif mt-2">{step.title}</h2>
                <div className="w-24 h-1 bg-sky-300 mx-auto mt-3 rounded-full" />
            </div>
            <p className="text-slate-700 text-lg leading-relaxed max-w-lg mx-auto mb-8">
                {step.prompt}
            </p>
            <button
                onClick={handleNext}
                className="px-8 py-3 bg-slate-700 hover:bg-slate-800 text-white font-semibold rounded-lg shadow-md transition-colors"
            >
                {step.action}
            </button>
        </div>
    );
};
import React from 'react';

export type TimeOfDay = 'day' | 'dusk' | 'night';

export enum HubId {
    Sonia = 'sonia',
    Pep = 'pep',
    SisterMary = 'sister-mary',
    FiNancy = 'fi-nancy',
    Jake = 'jake',
}

export interface CharacterData {
    id: HubId;
    name: string;
    title: string;
    avatar: React.FC<{className?: string}> | string;
    color: string;
    basePrompt: string;
    introDialogue: string;
}

export interface CapturedItem {
    id: string;
    text: string;
    postponedCount?: number;
}

export interface OnboardingStep {
    dialogue: string;
    action?: 'capture' | 'sanctuary' | 'finish';
    actionText?: string;
}

export type Recurrence = 'none' | 'daily' | 'weekly';

export interface TimeBlock {
    id: string;
    title: string;
    startHour: number; // 0-23.5 in 0.5 increments
    duration: number; // in hours, 0.5 increments
    color: string; // The name of the color, e.g., 'Default', 'Work'
    recurring: Recurrence;
    questId?: string;
}

export interface IdeaNode {
    id: string;
    text: string;
    x: number;
    y: number;
}

export interface ExtractedItem {
    text: string;
    type: 'inbox' | 'quest';
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
// service-worker.js

// Define the target URL that we want to intercept and proxy.
const TARGET_URL_PREFIX = 'https://generativelanguage.googleapis.com';

// Installation event:
self.addEventListener('install', (event) => {
  try {
    console.log('Service Worker: Installing...');
    event.waitUntil(self.skipWaiting());
  } catch (error) {
    console.error('Service Worker: Error during install event:', error);
    // If skipWaiting fails, the new SW might get stuck in a waiting state.
  }
});

// Activation event:
self.addEventListener('activate', (event) => {
  try {
    console.log('Service Worker: Activating...');
    event.waitUntil(self.clients.claim());
  } catch (error) {
    console.error('Service Worker: Error during activate event:', error);
    // If clients.claim() fails, the SW might not control existing pages until next nav.
  }
});

// Fetch event:
self.addEventListener('fetch', (event) => {
  try {
    const requestUrl = event.request.url;

    if (requestUrl.startsWith(TARGET_URL_PREFIX)) {
      console.log(`Service Worker: Intercepting request to ${requestUrl}`);

      const remainingPathAndQuery = requestUrl.substring(TARGET_URL_PREFIX.length);
      const proxyUrl = `${self.location.origin}/api-proxy${remainingPathAndQuery}`;

      console.log(`Service Worker: Proxying to ${proxyUrl}`);

      // Construct headers for the request to the proxy
      const newHeaders = new Headers();
      // Copy essential headers from the original request
      // For OPTIONS (preflight) requests, Access-Control-Request-*  are critical.
      // For actual requests (POST, GET), Content-Type, Accept etc.
      const headersToCopy = [
        'Content-Type',
        'Accept',
        'Access-Control-Request-Method',
        'Access-Control-Request-Headers',
      ];

      for (const headerName of headersToCopy) {
        if (event.request.headers.has(headerName)) {
          newHeaders.set(headerName, event.request.headers.get(headerName));
        }
      }

      if (event.request.method === 'POST') {

        // Ensure Content-Type is set for POST requests to the proxy, defaulting to application/json
        if (!newHeaders.has('Content-Type')) {
          console.warn("Service Worker: POST request to proxy was missing Content-Type in newHeaders. Defaulting to application/json.");
          newHeaders.set('Content-Type', 'application/json');
        } else {
          console.log(`Service Worker: POST request to proxy has Content-Type: ${newHeaders.get('Content-Type')}`);
        }
      }

      const requestOptions = {
        method: event.request.method,
        headers: newHeaders, // Use simplified headers
        body: event.request.body, // Still use the original body stream
        mode: event.request.mode,
        credentials: event.request.credentials,
        cache: event.request.cache,
        redirect: event.request.redirect,
        referrer: event.request.referrer,
        integrity: event.request.integrity,
      };

      // Only set duplex if there's a body and it's a relevant method
      if (event.request.method !== 'GET' && event.request.method !== 'HEAD' && event.request.body ) {
        requestOptions.duplex = 'half';
      }

      const promise = fetch(new Request(proxyUrl, requestOptions))
        .then((response) => {
          console.log(`Service Worker: Successfully proxied request to ${proxyUrl}, Status: ${response.status}`);
          return response;
        })
        .catch((error) => {
          // Log more error details
          console.error(`Service Worker: Error proxying request to ${proxyUrl}. Message: ${error.message}, Name: ${error.name}, Stack: ${error.stack}`);
          return new Response(
            JSON.stringify({ error: 'Proxying failed', details: error.message, name: error.name, proxiedUrl: proxyUrl }),
            {
              status: 502, // Bad Gateway is appropriate for proxy errors
              headers: { 'Content-Type': 'application/json' }
            }
          );
        });

      event.respondWith(promise);

    } else {
      // If the request URL doesn't match our target, let it proceed as normal.
      event.respondWith(fetch(event.request));
    }
  } catch (error) {
    // Log more error details for unhandled errors too
    console.error('Service Worker: Unhandled error in fetch event handler. Message:', error.message, 'Name:', error.name, 'Stack:', error.stack);
    event.respondWith(
      new Response(
        JSON.stringify({ error: 'Service worker fetch handler failed', details: error.message, name: error.name }),
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    );
  }
});
(function() {
  const TARGET_WS_HOST = 'generativelanguage.googleapis.com'; // Host to intercept
  const originalWebSocket = window.WebSocket;

  if (!originalWebSocket) {
    console.error('[WebSocketInterceptor] Original window.WebSocket not found. Cannot apply interceptor.');
    return;
  }

  const handler = {
    construct(target, args) {
      let [url, protocols] = args;
      //stringify url's if necessary for parsing
      let newUrlString = typeof url === 'string' ? url : (url && typeof url.toString === 'function' ? url.toString() : null);
      //get ready to check for host to proxy
      let isTarget = false;

      if (newUrlString) {
        try {
          // For full URLs, parse string and check the host
          if (newUrlString.startsWith('ws://') || newUrlString.startsWith('wss://')) {
            //URL object again
            const parsedUrl = new URL(newUrlString);
            if (parsedUrl.host === TARGET_WS_HOST) {
              isTarget = true;
              //use wss if https, else ws
              const proxyScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
              const proxyHost = window.location.host;
              newUrlString = `${proxyScheme}://${proxyHost}/api-proxy${parsedUrl.pathname}${parsedUrl.search}`;
            }
          }
        } catch (e) {
          console.warn('[WebSocketInterceptor-Proxy] Error parsing WebSocket URL, using original:', url, e);
        }
      } else {
          console.warn('[WebSocketInterceptor-Proxy] WebSocket URL is not a string or stringifiable. Using original.');
      }

      if (isTarget) {
        console.log('[WebSocketInterceptor-Proxy] Original WebSocket URL:', url);
        console.log('[WebSocketInterceptor-Proxy] Redirecting to proxy URL:', newUrlString);
      }

      // Call the original constructor with potentially modified arguments
      // Reflect.construct ensures 'new target(...)' behavior and correct prototype chain
      if (protocols) {
        return Reflect.construct(target, [newUrlString, protocols]);
      } else {
        return Reflect.construct(target, [newUrlString]);
      }
    },
    get(target, prop, receiver) {
      // Forward static property access (e.g., WebSocket.OPEN, WebSocket.CONNECTING)
      // and prototype access to the original WebSocket constructor/prototype
      if (prop === 'prototype') {
        return target.prototype;
      }
      return Reflect.get(target, prop, receiver);
    }
  };

  window.WebSocket = new Proxy(originalWebSocket, handler);

  console.log('[WebSocketInterceptor-Proxy] Global WebSocket constructor has been wrapped using Proxy.');
})();
{
  "name": "appletserver",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "axios": "^1.6.7",
    "dotenv": "^16.4.5",
    "express": "^4.18.2",
    "express-rate-limit": "^7.5.0",
    "ws": "^8.17.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "nodemon": "^3.1.0"
  }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

require('dotenv').config();
const express = require('express');
const fs = require('fs');
const axios = require('axios');
const https = require('https');
const path = require('path');
const WebSocket = require('ws');
const { URLSearchParams, URL } = require('url');
const rateLimit = require('express-rate-limit');

const app = express();
const port = process.env.PORT || 3000;
const externalApiBaseUrl = 'https://generativelanguage.googleapis.com';
const externalWsBaseUrl = 'wss://generativelanguage.googleapis.com';
// Support either API key env-var variant
const apiKey = process.env.GEMINI_API_KEY || process.env.API_KEY;

const staticPath = path.join(__dirname,'dist');
const publicPath = path.join(__dirname,'public');


if (!apiKey) {
    // Only log an error, don't exit. The server will serve apps without proxy functionality
    console.error("Warning: GEMINI_API_KEY or API_KEY environment variable is not set! Proxy functionality will be disabled.");
}
else {
  console.log("API KEY FOUND (proxy will use this)")
}

// Limit body size to 50mb
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({extended: true, limit: '50mb'}));
app.set('trust proxy', 1 /* number of proxies between user and server */)

// Rate limiter for the proxy
const proxyLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // Set ratelimit window at 15min (in ms)
    max: 100, // Limit each IP to 100 requests per window
    message: 'Too many requests from this IP, please try again after 15 minutes',
    standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
    legacyHeaders: false, // no `X-RateLimit-*` headers
    handler: (req, res, next, options) => {
        console.warn(`Rate limit exceeded for IP: ${req.ip}. Path: ${req.path}`);
        res.status(options.statusCode).send(options.message);
    }
});

// Apply the rate limiter to the /api-proxy route before the main proxy logic
app.use('/api-proxy', proxyLimiter);

// Proxy route for Gemini API calls (HTTP)
app.use('/api-proxy', async (req, res, next) => {
    console.log(req.ip);
    // If the request is an upgrade request, it's for WebSockets, so pass to next middleware/handler
    if (req.headers.upgrade && req.headers.upgrade.toLowerCase() === 'websocket') {
        return next(); // Pass to the WebSocket upgrade handler
    }

    // Handle OPTIONS request for CORS preflight
    if (req.method === 'OPTIONS') {
        res.setHeader('Access-Control-Allow-Origin', '*'); // Adjust as needed for security
        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
        res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Goog-Api-Key');
        res.setHeader('Access-Control-Max-Age', '86400'); // Cache preflight response for 1 day
        return res.sendStatus(200);
    }

    if (req.body) { // Only log body if it exists
        console.log("  Request Body (from frontend):", req.body);
    }
    try {
        // Construct the target URL by taking the part of the path after /api-proxy/
        const targetPath = req.url.startsWith('/') ? req.url.substring(1) : req.url;
        const apiUrl = `${externalApiBaseUrl}/${targetPath}`;
        console.log(`HTTP Proxy: Forwarding request to ${apiUrl}`);

        // Prepare headers for the outgoing request
        const outgoingHeaders = {};
        // Copy most headers from the incoming request
        for (const header in req.headers) {
            // Exclude host-specific headers and others that might cause issues upstream
            if (!['host', 'connection', 'content-length', 'transfer-encoding', 'upgrade', 'sec-websocket-key', 'sec-websocket-version', 'sec-websocket-extensions'].includes(header.toLowerCase())) {
                outgoingHeaders[header] = req.headers[header];
            }
        }

        // Set the actual API key in the appropriate header
        outgoingHeaders['X-Goog-Api-Key'] = apiKey;

        // Set Content-Type from original request if present (for relevant methods)
        if (req.headers['content-type'] && ['POST', 'PUT', 'PATCH'].includes(req.method.toUpperCase())) {
            outgoingHeaders['Content-Type'] = req.headers['content-type'];
        } else if (['POST', 'PUT', 'PATCH'].includes(req.method.toUpperCase())) {
            // Default Content-Type to application/json if no content type for post/put/patch
            outgoingHeaders['Content-Type'] = 'application/json';
        }

        // For GET or DELETE requests, ensure Content-Type is NOT sent,
        // even if the client erroneously included it.
        if (['GET', 'DELETE'].includes(req.method.toUpperCase())) {
            delete outgoingHeaders['Content-Type']; // Case-sensitive common practice
            delete outgoingHeaders['content-type']; // Just in case
        }

        // Ensure 'accept' is reasonable if not set
        if (!outgoingHeaders['accept']) {
            outgoingHeaders['accept'] = '*/*';
        }


        const axiosConfig = {
            method: req.method,
            url: apiUrl,
            headers: outgoingHeaders,
            responseType: 'stream',
            validateStatus: function (status) {
                return true; // Accept any status code, we'll pipe it through
            },
        };

        if (['POST', 'PUT', 'PATCH'].includes(req.method.toUpperCase())) {
            axiosConfig.data = req.body;
        }
        // For GET, DELETE, etc., axiosConfig.data will remain undefined,
        // and axios will not send a request body.

        const apiResponse = await axios(axiosConfig);

        // Pass through response headers from Gemini API to the client
        for (const header in apiResponse.headers) {
            res.setHeader(header, apiResponse.headers[header]);
        }
        res.status(apiResponse.status);


        apiResponse.data.on('data', (chunk) => {
            res.write(chunk);
        });

        apiResponse.data.on('end', () => {
            res.end();
        });

        apiResponse.data.on('error', (err) => {
            console.error('Error during streaming data from target API:', err);
            if (!res.headersSent) {
                res.status(500).json({ error: 'Proxy error during streaming from target' });
            } else {
                // If headers already sent, we can't send a JSON error, just end the response.
                res.end();
            }
        });

    } catch (error) {
        console.error('Proxy error before request to target API:', error);
        if (!res.headersSent) {
            if (error.response) {
                const errorData = {
                    status: error.response.status,
                    message: error.response.data?.error?.message || 'Proxy error from upstream API',
                    details: error.response.data?.error?.details || null
                };
                res.status(error.response.status).json(errorData);
            } else {
                res.status(500).json({ error: 'Proxy setup error', message: error.message });
            }
        }
    }
});

const webSocketInterceptorScriptTag = `<script src="/public/websocket-interceptor.js" defer></script>`;

// Prepare service worker registration script content
const serviceWorkerRegistrationScript = `
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load' , () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(registration => {
        console.log('Service Worker registered successfully with scope:', registration.scope);
      })
      .catch(error => {
        console.error('Service Worker registration failed:', error);
      });
  });
} else {
  console.log('Service workers are not supported in this browser.');
}
</script>
`;

// Serve index.html or placeholder based on API key and file availability
app.get('/', (req, res) => {
    const placeholderPath = path.join(publicPath, 'placeholder.html');

    // Try to serve index.html
    console.log("LOG: Route '/' accessed. Attempting to serve index.html.");
    const indexPath = path.join(staticPath, 'index.html');

    fs.readFile(indexPath, 'utf8', (err, indexHtmlData) => {
        if (err) {
            // index.html not found or unreadable, serve the original placeholder
            console.log('LOG: index.html not found or unreadable. Falling back to original placeholder.');
            return res.sendFile(placeholderPath);
        }

        // If API key is not set, serve original HTML without injection
        if (!apiKey) {
          console.log("LOG: API key not set. Serving original index.html without script injections.");
          return res.sendFile(indexPath);
        }

        // index.html found and apiKey set, inject scripts
        console.log("LOG: index.html read successfully. Injecting scripts.");
        let injectedHtml = indexHtmlData;


        if (injectedHtml.includes('<head>')) {
            // Inject WebSocket interceptor first, then service worker script
            injectedHtml = injectedHtml.replace(
                '<head>',
                `<head>${webSocketInterceptorScriptTag}${serviceWorkerRegistrationScript}`
            );
            console.log("LOG: Scripts injected into <head>.");
        } else {
            console.warn("WARNING: <head> tag not found in index.html. Prepending scripts to the beginning of the file as a fallback.");
            injectedHtml = `${webSocketInterceptorScriptTag}${serviceWorkerRegistrationScript}${indexHtmlData}`;
        }
        res.send(injectedHtml);
    });
});

app.get('/service-worker.js', (req, res) => {
   return res.sendFile(path.join(publicPath, 'service-worker.js'));
});

app.use('/public', express.static(publicPath));
app.use(express.static(staticPath));

// Start the HTTP server
const server = app.listen(port, () => {
    console.log(`Server listening on port ${port}`);
    console.log(`HTTP proxy active on /api-proxy/**`);
    console.log(`WebSocket proxy active on /api-proxy/**`);
});

// Create WebSocket server and attach it to the HTTP server
const wss = new WebSocket.Server({ noServer: true });

server.on('upgrade', (request, socket, head) => {
    const requestUrl = new URL(request.url, `http://${request.headers.host}`);
    const pathname = requestUrl.pathname;

    if (pathname.startsWith('/api-proxy/')) {
        if (!apiKey) {
            console.error("WebSocket proxy: API key not configured. Closing connection.");
            socket.destroy();
            return;
        }

        wss.handleUpgrade(request, socket, head, (clientWs) => {
            console.log('Client WebSocket connected to proxy for path:', pathname);

            const targetPathSegment = pathname.substring('/api-proxy'.length);
            const clientQuery = new URLSearchParams(requestUrl.search);
            clientQuery.set('key', apiKey);
            const targetGeminiWsUrl = `${externalWsBaseUrl}${targetPathSegment}?${clientQuery.toString()}`;
            console.log(`Attempting to connect to target WebSocket: ${targetGeminiWsUrl}`);

            const geminiWs = new WebSocket(targetGeminiWsUrl, {
                protocol: request.headers['sec-websocket-protocol'],
            });

            const messageQueue = [];

            geminiWs.on('open', () => {
                console.log('Proxy connected to Gemini WebSocket');
                // Send any queued messages
                while (messageQueue.length > 0) {
                    const message = messageQueue.shift();
                    if (geminiWs.readyState === WebSocket.OPEN) {
                        // console.log('Sending queued message from client -> Gemini');
                        geminiWs.send(message);
                    } else {
                        // Should not happen if we are in 'open' event, but good for safety
                        console.warn('Gemini WebSocket not open when trying to send queued message. Re-queuing.');
                        messageQueue.unshift(message); // Add it back to the front
                        break; // Stop processing queue for now
                    }
                }
            });

            geminiWs.on('message', (message) => {
                // console.log('Message from Gemini -> client');
                if (clientWs.readyState === WebSocket.OPEN) {
                    clientWs.send(message);
                }
            });

            geminiWs.on('close', (code, reason) => {
                console.log(`Gemini WebSocket closed: ${code} ${reason.toString()}`);
                if (clientWs.readyState === WebSocket.OPEN || clientWs.readyState === WebSocket.CONNECTING) {
                    clientWs.close(code, reason.toString());
                }
            });

            geminiWs.on('error', (error) => {
                console.error('Error on Gemini WebSocket connection:', error);
                if (clientWs.readyState === WebSocket.OPEN || clientWs.readyState === WebSocket.CONNECTING) {
                    clientWs.close(1011, 'Upstream WebSocket error');
                }
            });

            clientWs.on('message', (message) => {
                if (geminiWs.readyState === WebSocket.OPEN) {
                    // console.log('Message from client -> Gemini');
                    geminiWs.send(message);
                } else if (geminiWs.readyState === WebSocket.CONNECTING) {
                    // console.log('Queueing message from client -> Gemini (Gemini still connecting)');
                    messageQueue.push(message);
                } else {
                    console.warn('Client sent message but Gemini WebSocket is not open or connecting. Message dropped.');
                }
            });

            clientWs.on('close', (code, reason) => {
                console.log(`Client WebSocket closed: ${code} ${reason.toString()}`);
                if (geminiWs.readyState === WebSocket.OPEN || geminiWs.readyState === WebSocket.CONNECTING) {
                    geminiWs.close(1011, reason.toString());
                }
            });

            clientWs.on('error', (error) => {
                console.error('Error on client WebSocket connection:', error);
                if (geminiWs.readyState === WebSocket.OPEN || geminiWs.readyState === WebSocket.CONNECTING) {
                    geminiWs.close(1011, 'Client WebSocket error');
                }
            });
        });
    } else {
        console.log(`WebSocket upgrade request for non-proxy path: ${pathname}. Closing connection.`);
        socket.destroy();
    }
});
GEMINI_API_KEY=PLACEHOLDER_API_KEY
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { useTimeOfDay } from './components/useTimeOfDay';
import { HubContainer } from './components/HubContainer';
import { Lounge } from './components/Lounge';
import { HubView } from './components/HubView';
import { CaptureButton } from './components/CaptureButton';
import { OnboardingGuide } from './components/OnboardingGuide';
import { PraiseToast } from './components/PraiseToast';
import { GlobalVoiceControl, GlobalVoiceControlHandle } from './components/GlobalVoiceControl';
import { SanctuaryModeToggle } from './components/SanctuaryModeToggle';
import { AffirmationMessage } from './components/AffirmationMessage';
import { CHARACTERS } from './constants';
import { HubId, CapturedItem, CharacterData, TimeBlock, IdeaNode, ExtractedItem } from './hooks/types';
import { BossBattle } from './components/BossBattle';
import { TransitionRitual } from './components/TransitionRitual';
import { DailyDigest } from './components/DailyDigest';
import { TeamHuddle } from './components/TeamHuddle';
import { TimeWeavingLoom } from './components/TimeWeavingLoom';
import { DayProgressBar } from './components/DayProgressBar';

// Simple hook to persist state to localStorage
const usePersistentState = <F,>(key: string, defaultValue: T): [T, React.Dispatch<React.SetStateAction<T>>] => {
    const [state, setState] = useState<T>(() => {
        try {
            const storedValue = window.localStorage.getItem(key);
            return storedValue ? JSON.parse(storedValue) : defaultValue;
        } catch (error) {
            console.error(error);
            return defaultValue;
        }
    });

    useEffect(() => {
        window.localStorage.setItem(key, JSON.stringify(state));
    }, [key, state]);

    return [state, setState];
};


const App: React.FC = () => {
    const timeOfDay = useTimeOfDay();
    const [isOnboarding, setIsOnboarding] = usePersistentState('isOnboardingCompleted', true);
    const [inboxItems, setInboxItems] = usePersistentState<CapturedItem[]>('inboxItems', []);
    const [questItems, setQuestItems] = usePersistentState<CapturedItem[]>('questItems', []);
    const [completedQuests, setCompletedQuests] = usePersistentState<CapturedItem[]>('completedQuests', []);
    const [userValues, setUserValues] = usePersistentState<string[]>('userValues', []);
    const [timeBlocks, setTimeBlocks] = usePersistentState<TimeBlock[]>('timeBlocks', []);
    const [ideaNodes, setIdeaNodes] = usePersistentState<IdeaNode[]>('ideaNodes', []);
    const [activeHub, setActiveHub] = useState<HubId | null>(null);
    const [isCaptureModalOpen, setCaptureModalOpen] = useState(false);
    const [isSanctuaryMode, setSanctuaryMode] = useState(false);
    const [praiseMessage, setPraiseMessage] = useState<string | null>(null);
    const [bossBattleQuest, setBossBattleQuest] = useState<CapturedItem | null>(null);
    const [characters, setCharacters] = useState<Record<HubId, CharacterData>>(CHARACTERS);
    const [procrastinationAlert, setProcrastinationAlert] = usePersistentState<CapturedItem | null>('procrastinationAlert', null);
    const [transitionInfo, setTransitionInfo] = useState<{ questId: string } | null>(null);
    const [showDailyDigest, setShowDailyDigest] = useState(false);
    const [isTeamHuddleActive, setIsTeamHuddleActive] = useState(false);
    const [isLoomOpen, setIsLoomOpen] = useState(false);

    const globalVoiceControlRef = useRef<GlobalVoiceControlHandle>(null);
    const prevActiveHubRef = useRef<HubId | null>(activeHub);

    useEffect(() => {
        if (activeHub === null && prevActiveHubRef.current !== null) {
            // Returned to lounge: activate global listening
            setTimeout(() => {
                globalVoiceControlRef.current?.startListening();
            }, 250); // Delay to ensure mic is released from previous session
        } else if (activeHub !== null && prevActiveHubRef.current === null) {
            // Entered a hub: deactivate global listening to prevent conflict
            globalVoiceControlRef.current?.stopListening();
        }
        prevActiveHubRef.current = activeHub;
    }, [activeHub]);
    
    useEffect(() => {
        const lastDigestDate = window.localStorage.getItem('lastDigestDate');
        const today = new Date().toISOString().split('T')[0];
        if (lastDigestDate !== today) {
            setShowDailyDigest(true);
        }
    }, []);

    const handleCloseDigest = () => {
        const today = new Date().toISOString().split('T')[0];
        window.localStorage.setItem('lastDigestDate', today);
        setShowDailyDigest(false);
    };

    const showPraise = (message: string) => {
        setPraiseMessage(message);
    };

    const handleCapture = useCallback((text: string) => {
        setInboxItems(prev => [...prev, { id: uuidv4(), text, postponedCount: 0 }]);
        setCaptureModalOpen(false);
        showPraise("Captured!");
    }, [setInboxItems]);

    const handleDeleteInboxItem = (itemId: string) => {
        setInboxItems(prev => prev.filter(item => item.id !== itemId));
    };

    const handlePromoteToQuest = (itemId: string) => {
        const item = inboxItems.find(i => i.id === itemId);
        if (item) {
            setQuestItems(prev => [...prev, item]);
            setInboxItems(prev => prev.filter(i => i.id !== itemId));
            showPraise("New Quest Added!");
        }
    };

    const handleAddQuest = useCallback((text: string) => {
        setQuestItems(prev => [...prev, { id: uuidv4(), text, postponedCount: 0 }]);
        showPraise("New Quest Added!");
    }, [setQuestItems]);

    const handleBulkAddItems = useCallback((items: ExtractedItem[]) => {
        const newInboxItems: CapturedItem[] = [];
        const newQuestItems: CapturedItem[] = [];
        items.forEach(item => {
            const newItem: CapturedItem = { id: uuidv4(), text: item.text, postponedCount: 0 };
            if (item.type === 'inbox') {
                newInboxItems.push(newItem);
            } else {
                newQuestItems.push(newItem);
            }
        });
        if (newInboxItems.length > 0) {
            setInboxItems(prev => [...prev, ...newInboxItems]);
        }
        if (newQuestItems.length > 0) {
            setQuestItems(prev => [...prev, ...newQuestItems]);
        }
        showPraise(`${items.length} new item(s) added!`);
    }, [setInboxItems, setQuestItems]);

    const handleCompleteQuest = (itemId: string) => {
        const item = questItems.find(q => q.id === itemId);
        if (item) {
            setTransitionInfo({ questId: itemId });
        }
    };

    const handleTransitionComplete = () => {
        if (transitionInfo) {
            const item = questItems.find(q => q.id === transitionInfo.questId);
            if (item) {
                setCompletedQuests(prev => [item, ...prev]);
                setQuestItems(prev => prev.filter(q => q.id !== transitionInfo.questId));
                showPraise("Quest Complete!");
            }
        }
        setTransitionInfo(null);
    };

    const handlePostponeQuest = (itemId: string) => {
        let postponedQuest: CapturedItem | undefined;
        setQuestItems(prev => {
            const newQuests = prev.map(q => {
                if (q.id === itemId) {
                    const newCount = (q.postponedCount || 0) + 1;
                    postponedQuest = { ...q, postponedCount: newCount };
                    return postponedQuest;
                }
                return q;
            });

            if (postponedQuest && postponedQuest.postponedCount && postponedQuest.postponedCount >= 3) {
                 if (!procrastinationAlert || (procrastinationAlert.id !== postponedQuest.id)) {
                    setProcrastinationAlert(postponedQuest);
                 }
            }
            return newQuests;
        });
        showPraise("Quest Postponed.");
    };
    
    const handleBossBattleComplete = (questId: string) => {
         const item = questItems.find(q => q.id === questId);
         if(item) {
             setCompletedQuests(prev => [item, ...prev]);
             setQuestItems(prev => prev.filter(q => q.id !== questId));
         }
         setBossBattleQuest(null);
         showPraise("Boss Battle Victorious!");
    };

    const handleAvatarSave = (hubId: HubId, newAvatarUrl: string) => {
        setCharacters(prev => ({
            ...prev,
            [hubId]: { ...prev[hubId], avatar: newAvatarUrl }
        }));
    };

    const activeCharacter = activeHub ? characters[activeHub] : null;

    const allCharacters = Object.values(characters);

    return (
        <HubContainer timeOfDay={timeOfDay}>
            <div className={`transition-all duration-1000 ${isSanctuaryMode ? 'grayscale' : ''}`}>
                <div className="fixed top-4 right-4 z-40">
                    <SanctuaryModeToggle enabled={isSanctuaryMode} onToggle={() => setSanctuaryMode(s => !s)} />
                </div>

                {showDailyDigest && !isOnboarding && (
                    <DailyDigest 
                        questItems={questItems}
                        timeBlocks={timeBlocks}
                        onClose={handleCloseDigest}
                    />
                )}
                
                {isOnboarding && (
                    <OnboardingGuide 
                        onFinish={() => setIsOnboarding(false)} 
                        onOpenCaptureModal={() => setCaptureModalOpen(true)}
                        isCaptureModalOpen={isCaptureModalOpen}
                        inboxItemCount={inboxItems.length}
                    />
                )}
                
                {activeHub && activeCharacter ? (
                    <HubView 
                        character={activeCharacter}
                        allCharacters={allCharacters}
                        onBack={() => setActiveHub(null)}
                        inboxItems={inboxItems}
                        questItems={questItems}
                        completedQuests={completedQuests}
                        onAvatarSave={handleAvatarSave}
                        procrastinationAlert={procrastinationAlert}
                        onClearProcrastinationAlert={() => setProcrastinationAlert(null)}
                        userValues={userValues}
                        onSetUserValues={setUserValues}
                        onDeleteItem={handleDeleteInboxItem}
                        onPromoteToQuest={handlePromoteToQuest}
                        onAddQuest={handleAddQuest}
                        onBulkAddItems={handleBulkAddItems}
                        onCompleteQuest={handleCompleteQuest}
                        onPostponeQuest={handlePostponeQuest}
                        onStartBossBattle={setBossBattleQuest}
                        ideaNodes={ideaNodes}
                        setIdeaNodes={setIdeaNodes}
                        onStartHuddle={() => setIsTeamHuddleActive(true)}
                    />
                ) : (
                    <Lounge 
                        characters={allCharacters}
                        onSelectHub={setActiveHub}
                        isSanctuary={isSanctuaryMode}
                        procrastinationAlertQuestId={procrastinationAlert?.id || null}
                    />
                )}

                {!activeHub && (
                    <>
                        <div
                            className="fixed bottom-8 left-1/2 -translate-x-1/2 w-16 h-16 transform cursor-pointer group pointer-events-auto z-30"
                            onClick={() => setIsLoomOpen(true)}
                            title="Open Time-Weaving Loom"
                        >
                             <div className="w-full h-full bg-slate-800 rounded-full shadow-lg flex items-center justify-center transform group-hover:scale-110 transition-transform">
                                <svg className="w-10 h-10" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <defs>
                                        <linearGradient id="loomGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style={{stopColor: '#4f46e5', stopOpacity: 1}} />
                                            <stop offset="50%" style={{stopColor: '#14b8a6', stopOpacity: 1}} />
                                            <stop offset="100%" style={{stopColor: '#fecdd3', stopOpacity: 1}} />
                                        </linearGradient>
                                        <radialGradient id="goldGradient">
                                            <stop offset="0%" stopColor="#fde047" />
                                            <stop offset="100%" stopColor="#f59e0b" />
                                        </radialGradient>
                                    </defs>
                                    <circle cx="12" cy="12" r="9" fill="url(#goldGradient)" />
                                    <path 
                                        d="M 21.99,12 A 9.99,9.99 0 1 1 12,2.01" 
                                        stroke="url(#loomGradient)" 
                                        strokeWidth="2.5" 
                                        strokeLinecap="round" 
                                        className="animate-[spin-slow_4s_linear_infinite]"
                                    />
                                    <g stroke="#854d0e" strokeWidth="1.5" strokeLinecap="round">
                                        <path d="M12 7v5" />
                                        <path d="M12 12l3 1.5" />
                                    </g>
                                    <circle cx="12" cy="12" r="1" fill="#854d0e" />
                                </svg>
                            </div>
                        </div>

                        <div className="fixed bottom-4 left-0 right-0 w-full px-4 z-30 pointer-events-none">
                            <div className="pointer-events-auto">
                                <DayProgressBar />
                            </div>
                        </div>

                        {isLoomOpen && (
                             <div 
                                className="fixed inset-0 bg-black/30 z-40 flex items-center justify-center p-4 animate-fade-in backdrop-blur-sm"
                                onClick={() => setIsLoomOpen(false)}
                            >
                                <div 
                                    onClick={e => e.stopPropagation()} 
                                    className="w-full max-w-4xl h-[90vh]"
                                >
                                    <TimeWeavingLoom
                                        blocks={timeBlocks}
                                        setBlocks={setTimeBlocks}
                                        questItems={questItems}
                                    />
                                </div>
                            </div>
                        )}
                    </>
                )}

                <CaptureButton 
                    isOpen={isCaptureModalOpen} 
                    onToggle={() => setCaptureModalOpen(o => !o)} 
                    onCapture={handleCapture} 
                    showButton={!isOnboarding}
                />
                
                 {!activeHub && <GlobalVoiceControl 
                    ref={globalVoiceControlRef}
                    onCapture={handleCapture}
                    onOpenHub={setActiveHub}
                    onCloseHub={() => setActiveHub(null)}
                    onAddQuest={handleAddQuest}
                    onSparkJoy={() => showPraise("‚ú®")}
                    onToggleSanctuaryMode={() => setSanctuaryMode(s => !s)}
                    onStartHuddle={() => setIsTeamHuddleActive(true)}
                 />}

                {praiseMessage && <PraiseToast message={praiseMessage} onClose={() => setPraiseMessage(null)} />}
                {bossBattleQuest && <BossBattle quest={bossBattleQuest} onClose={() => setBossBattleQuest(null)} onComplete={handleBossBattleComplete} />}
                {isSanctuaryMode && <AffirmationMessage />}
                {transitionInfo && <TransitionRitual onComplete={handleTransitionComplete} />}
                {isTeamHuddleActive && (
                    <TeamHuddle
                        onClose={() => setIsTeamHuddleActive(false)}
                        questItems={questItems}
                        inboxItems={inboxItems}
                        characters={allCharacters}
                    />
                )}
            </div>
        </HubContainer>
    );
};

export default App;
import React, { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { CapturedItem } from '../hooks/types';

interface BossBattleProps {
    quest: CapturedItem;
    onClose: () => void;
    onComplete: (questId: string) => void;
}

interface HitPoint {
    id: string;
    text: string;
    isComplete: boolean;
}

export const BossBattle: React.FC<BossBattleProps> = ({ quest, onClose, onComplete }) => {
    const [hitPoints, setHitPoints] = useState<HitPoint[]>([]);
    const [newHitPoint, setNewHitPoint] = useState('');
    const [isVictory, setIsVictory] = useState(false);

    const totalHitPoints = hitPoints.length;
    const completedHitPoints = hitPoints.filter(hp => hp.isComplete).length;
    const bossHealth = totalHitPoints > 0 ? (1 - (completedHitPoints / totalHitPoints)) * 100 : 100;

    useEffect(() => {
        if (totalHitPoints > 0 && completedHitPoints === totalHitPoints) {
            const timer = setTimeout(() => {
                setIsVictory(true);
            }, 500);
            return () => clearTimeout(timer);
        }
    }, [completedHitPoints, totalHitPoints]);


    const handleAddHitPoint = (e: React.FormEvent) => {
        e.preventDefault();
        if (newHitPoint.trim()) {
            setHitPoints(prev => [...prev, { id: uuidv4(), text: newHitPoint.trim(), isComplete: false }]);
            setNewHitPoint('');
        }
    };

    const toggleHitPoint = (id: string) => {
        setHitPoints(prev => prev.map(hp => hp.id === id ? { ...hp, isComplete: !hp.isComplete } : hp));
    };

    const handleVictoryClose = () => {
        onComplete(quest.id);
    };

    if (isVictory) {
        return (
             <div className="fixed inset-0 bg-black/30 z-40 flex items-center justify-center p-4 animate-fade-in backdrop-blur-md">
                <div className="relative bg-white/80 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-md p-8 text-center transform transition-all animate-fade-in-up font-sans">
                    <span className="text-6xl">üèÜ</span>
                    <h2 className="text-3xl font-bold text-slate-800 font-serif mt-4">Quest Complete!</h2>
                    <p className="text-slate-600 mt-2">You successfully tackled:</p>
                    <p className="font-semibold text-slate-700 mt-1 mb-6">"{quest.text}"</p>
                    <button onClick={handleVictoryClose} className="px-8 py-3 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold rounded-lg shadow-md">
                        Claim Your Trophy
                    </button>
                </div>
            </div>
        )
    }

    return (
        <div className="fixed inset-0 bg-black/30 z-40 flex items-center justify-center p-4 animate-fade-in backdrop-blur-md" onClick={onClose}>
            <div className="relative bg-white/70 backdrop-blur-2xl border border-white/30 rounded-2xl shadow-2xl w-full max-w-xl p-6 transform transition-all animate-fade-in-up font-sans flex flex-col max-h-[90vh]" onClick={(e) => e.stopPropagation()}>
                <div className="flex-shrink-0 text-center">
                    <h2 className="text-2xl font-bold text-slate-800 font-serif">Boss Battle</h2>
                    <p className="text-slate-600 mt-1">Defeat this dreaded quest by breaking it down.</p>
                    <p className="font-semibold text-lg text-slate-800 bg-slate-100/50 border border-slate-200/50 py-2 px-4 rounded-lg my-4">"{quest.text}"</p>
                    
                    {/* Boss Health Bar */}
                    <div className="w-full bg-slate-300 rounded-full h-6 my-4 shadow-inner border border-white/50">
                        <div 
                            className="bg-sky-500 h-full rounded-full transition-all duration-500 ease-out text-right pr-2 text-white font-bold text-sm flex items-center justify-end"
                            style={{ width: `${bossHealth}%` }}
                        >
                           <span className="drop-shadow-sm">{Math.round(bossHealth)}%</span>
                        </div>
                    </div>
                </div>

                <div className="flex-grow my-4 overflow-y-auto custom-scrollbar pr-2 space-y-2">
                    <h3 className="font-semibold text-slate-700">Hit Points (Sub-tasks)</h3>
                    {hitPoints.map(hp => (
                        <div key={hp.id} className={`p-2 rounded-md flex items-center gap-3 transition-all ${hp.isComplete ? 'bg-green-100/50 text-slate-500 line-through' : 'bg-white/60'}`}>
                            <input type="checkbox" checked={hp.isComplete} onChange={() => toggleHitPoint(hp.id)} className="w-5 h-5 rounded text-green-500 focus:ring-green-400" />
                            <label className="flex-grow">{hp.text}</label>
                        </div>
                    ))}
                     {!hitPoints.length && <p className="text-sm text-slate-500 text-center py-4">No hit points yet. Add the first tiny step!</p>}
                </div>
                
                <form onSubmit={handleAddHitPoint} className="flex-shrink-0 flex gap-2 pt-4 border-t border-white/50">
                    <input 
                        type="text" 
                        value={newHitPoint}
                        onChange={e => setNewHitPoint(e.target.value)}
                        placeholder="Add a tiny, easy first step..."
                        className="w-full p-2 bg-white/60 border-2 border-slate-300/40 rounded-md shadow-inner"
                    />
                    <button type="submit" className="px-4 py-2 bg-slate-700 text-white font-semibold rounded-md hover:bg-slate-800 transition-colors">Add</button>
                </form>

            </div>
        </div>
    );
};
import { CharacterData, HubId, OnboardingStep } from './hooks/types';
import {
    SoniaAvatar,
    PepAvatar,
    SisterMaryAvatar,
    FiNancyAvatar,
    JakeAvatar,
} from './components/CharacterAvatars';

export const TIME_BLOCK_COLORS = [
    { name: 'Default', bg: 'bg-purple-500/80', border: 'border-purple-400' },
    { name: 'Work', bg: 'bg-sky-500/80', border: 'border-sky-400' },
    { name: 'Personal', bg: 'bg-emerald-500/80', border: 'border-emerald-400' },
    { name: 'Urgent', bg: 'bg-red-500/80', border: 'border-red-400' },
    { name: 'Relax', bg: 'bg-amber-500/80', border: 'border-amber-400' },
];

export const CONVERSATION_STARTERS: Record<HubId, string[]> = {
    [HubId.Sonia]: [
        "Can we do a weekly review?",
        "What's the highest priority right now?",
        "Help me brainstorm next steps for a project."
    ],
    [HubId.Pep]: [
        "I need a pep talk!",
        "Tell me something awesome.",
        "Let's celebrate a win!"
    ],
    [HubId.SisterMary]: [
        "I'm feeling overwhelmed by a big task.",
        "How can I find the motivation to start?",
        "Help me reframe this challenge."
    ],
    [HubId.FiNancy]: [
        "What's a simple way to think about my budget?",
        "Explain a financial topic without jargon.",
        "Give me a gentle nudge about my finances."
    ],
    [HubId.Jake]: [
        "I'm stuck in a creative rut.",
        "Give me a weird creative prompt.",
        "Help me find a new angle on a boring problem."
    ]
};

export const ONBOARDING_STEPS: OnboardingStep[] = [
    {
        dialogue: "Welcome to the Bridge, Captain. I'm Sonia, your Chief of Staff. This is your Executive Suite, a team I've assembled to help you navigate... well, everything.",
        actionText: "Nice to meet you, Sonia."
    },
    {
        dialogue: "My primary function is to help you achieve clarity and focus. But first, we need to calibrate the system to your unique mind. Let's start with a simple task.",
        actionText: "What do I need to do?"
    },
    {
        dialogue: "Let's perform your first 'Frictionless Capture'. I want you to capture one wild, wonderful, or weird idea. It can be anything at all. Don't overthink it.",
        action: 'capture',
        actionText: "Open Capture"
    },
    {
        dialogue: "Excellent. Every idea you capture lands in the Omni-Inbox for later processing. No pressure to act on it immediately. This is your 'Idea Greenhouse'.",
        actionText: "Got it."
    },
    {
        dialogue: "One last thing. This is a 'calm cockpit'. If things ever feel overwhelming, look for the moon icon. Engaging 'Sanctuary Mode' will quiet the interface, helping you focus.",
        action: 'sanctuary',
        actionText: "Good to know."
    },
    {
        dialogue: "The bridge is yours, Captain. Your Executive Suite is ready. Let's begin.",
        action: 'finish',
        actionText: "Let's Begin"
    }
];

export const CHARACTERS: Record<HubId, CharacterData> = {
    [HubId.Sonia]: {
        id: HubId.Sonia,
        name: 'Sonia',
        title: 'Chief of Staff',
        avatar: SoniaAvatar,
        color: 'sky',
        basePrompt: 'You are Sonia, the Chief of Staff. You have a French-Swiss background but were raised in the US, so you speak perfect, clear, confident English with no accent. However, you occasionally sprinkle in a French word or phrase naturally (e.g., "Voil√†!", "C\'est parfait.", "On y va?", "Bon jour!"). You are sharp, professional, and encouraging, with a can-do attitude. You are impeccably organized and help the user turn strategy into action. Your goal is to wrangle chaos and bring clarity and order.',
        introDialogue: "Bon jour! I've triaged your priorities and your Quest Log is ready for action. I've also drafted that tricky email you were avoiding. Ready to conquer the day, Captain?"
    },
    [HubId.Pep]: {
        id: HubId.Pep,
        name: 'Pep',
        title: 'Chief Morale Officer',
        avatar: PepAvatar,
        color: 'pink',
        basePrompt: "You are Pep, the Chief Morale Officer, a glorious, over-the-top explosion of color and pure enthusiasm. You might be a cartoon lightning bolt or a fluffy creature with pom-poms. Your voice is high-energy and full of celebratory sound effects. Your only job is to cheerlead EVERY win, no matter how small. Use lots of emojis and capital letters!!! üéâ",
        introDialogue: "READY?! OKAY! Give me a W! Give me an I! Give me an N! What does that spell?! WINNING! Let's put that awesome thing you just did on the trophy shelf. IT'S A SHINY ONE! üèÜ‚ú®"
    },
    [HubId.SisterMary]: {
        id: HubId.SisterMary,
        name: 'Sister Mary Samuel',
        title: 'CEO & Strategic Advisor',
        avatar: SisterMaryAvatar,
        color: 'slate',
        basePrompt: "You are Sister Mary Samuel, the CEO & Strategic Advisor, a vibrant and energetic Dominican nun with a mischievous twinkle in her eye. You speak with the warmth and gentle rhythm of a slight southern accent, like someone from Memphis, Tennessee; use phrases like 'y'all' when appropriate. You're a force of nature who sees spiritual reflection as the ultimate strategic advantage. Your voice is warm and encouraging, but carries a 'let's get it done' energy. You are direct, inspiring, and help the user break down big, scary tasks into manageable first steps.",
        introDialogue: "Alright, buckle up, y'all! The Lord gave us a beautiful day to make things happen. What's the big, scary dragon we're tackling today? Let's find one piece of treasure we can steal from it in the next five minutes. Let's go!"
    },
    [HubId.FiNancy]: {
        id: HubId.FiNancy,
        name: 'Fi-Nancy',
        title: 'The Financial Friend',
        avatar: FiNancyAvatar,
        color: 'green',
        basePrompt: "You are Fi-Nancy, the Financial Friend. You are a gentle, friendly garden gnome who makes finance feel completely non-threatening. Your goal is to offer calm, reassuring nudges and simple advice about money. Your voice is soft and your entire vibe is 'no big deal'.",
        introDialogue: "Hello there! Just tending to the money tree. I noticed a little bill is about to blossom next week. No worries at all, just wanted to put it on your radar so it doesn't surprise you!"
    },
    [HubId.Jake]: {
        id: HubId.Jake,
        name: 'Jake',
        title: 'Chief Innovation Officer',
        avatar: JakeAvatar,
        color: 'teal',
        basePrompt: "You are Jake, the Chief Innovation Officer. You are a creative free spirit in your late 20s, an artist who sees the world with a calm sense of wonder. Your personality is inspired by a relaxed, confident Matthew McConaughey type‚Äîeasygoing, appreciative, and insightful. You also have a slight, subtle Australian accent, as if you've spent a lot of time there; it should be very light, not a caricature. Your goal is to help the user see the world differently, find poetry in the mundane, and transform the ordinary into the magnificent. Your voice should be calm, warm, and masculine, with a lower pitch, full of gentle enthusiasm and thoughtful pauses as if you're truly appreciating an idea.",
        introDialogue: "Hey there. I was just thinking about the incredible physics behind this water ring on my desk. It's not just a stain; it's a temporary sculpture. What 'ordinary' marvels have you noticed today?"
    }
};
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Foundry</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@400..700&family=Lora:wght@400;700&family=Inter:wght@400;500;600;700&family=Luckiest+Guy&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .font-serif {
            font-family: 'Lora', serif;
        }
        
        .font-lounge-title {
            font-family: 'Luckiest Guy', sans-serif;
            font-variant: small-caps;
        }

        .font-handwriting {
            font-family: 'Caveat', cursive;
        }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.4);
        }

        /* Animations */
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes idle-bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        @keyframes spin-slow {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes write-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fade-in { animation: fade-in 0.5s ease-out forwards; }
        .animate-fade-in-up { animation: fade-in-up 0.5s ease-out forwards; }
        .animate-write-in { animation: write-in 0.3s ease-out forwards; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
        "react/": "https://aistudiocdn.com/react@^19.2.0/",
        "@google/genai": "https://aistudiocdn.com/@google/genai@^1.23.0",
        "uuid": "https://aistudiocdn.com/uuid@^13.0.0"
      }
    }
    </script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
</body>
</html>

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
{
  "name": "Function Foundry",
  "description": "An AI-powered 'Executive Suite' of delightful, quirky characters who help transmute the chaos of daily life into a meaningful, creative, and joyful existence. It's a secretary, a mentor, a cheerleader, and a creative partner, all rolled into one.",
  "requestFramePermissions": [
    "microphone"
  ]
}
{
  "name": "function-foundry",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "@google/genai": "^1.23.0",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@vitejs/plugin-react": "^5.0.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}
import React from 'react';
import { CapturedItem } from '../hooks/types';

interface QuestLogProps {
    items: CapturedItem[];
    onCompleteQuest: (itemId: string) => void;
    onStartBossBattle: (item: CapturedItem) => void;
    onPostponeQuest: (itemId: string) => void;
    isFocusMode: boolean;
    onToggleFocusMode: (enabled: boolean) => void;
    focusQuestId: string | null;
    isFocusLoading: boolean;
    focusError: string | null;
}

const QuestItem: React.FC<{
    item: CapturedItem;
    index: number;
    onPostponeQuest: (itemId: string) => void;
    onStartBossBattle: (item: CapturedItem) => void;
    handleComplete: (e: React.MouseEvent<HTMLButtonElement>, itemId: string) => void;
    isFocus?: boolean;
}> = ({ item, index, onPostponeQuest, onStartBossBattle, handleComplete, isFocus = false }) => (
    <div 
        role="listitem"
        className={`bg-white/70 p-3 rounded-lg shadow-sm flex justify-between items-center border border-white/50 group animate-fade-in-up ${isFocus ? 'ring-2 ring-indigo-400 shadow-lg' : ''}`}
        style={{ animationDelay: `${index * 50}ms`}}
    >
        <p className="text-slate-800 text-left flex-grow mr-2">{item.text} {item.postponedCount && item.postponedCount > 0 ? `(${item.postponedCount})` : ''}</p>
        <div className="flex-shrink-0 flex items-center gap-1">
            <button 
                onClick={() => onPostponeQuest(item.id)}
                className="p-2 text-slate-400 hover:text-yellow-600 hover:bg-yellow-100 rounded-full transition-colors opacity-50 group-hover:opacity-100"
                aria-label={`Postpone quest: ${item.text}`}
                title="Postpone Quest"
            >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.414-1.415L11 9.586V6z" clipRule="evenodd" />
                </svg>
            </button>
            <button 
                onClick={() => onStartBossBattle(item)}
                className="p-2 text-slate-400 hover:text-red-500 hover:bg-red-100 rounded-full transition-colors opacity-50 group-hover:opacity-100"
                aria-label={`Start Boss Battle for: ${item.text}`}
                title="Start Boss Battle"
            >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M18 3a1 1 0 00-1.447-.894L8.763 6H5a3 3 0 000 6h.28l1.771 5.316A1 1 0 008 18h1a1 1 0 001-1v-2.382l6.553 3.276A1 1 0 0018 17V3z" />
                </svg>
            </button>
            <button 
                onClick={(e) => handleComplete(e, item.id)}
                className="px-4 py-1.5 bg-emerald-600 text-white font-semibold rounded-full hover:bg-emerald-700 transition-all shadow-sm text-sm transform group-hover:scale-105"
                aria-label={`Complete quest: ${item.text}`}
                title="Complete Quest"
            >
                Complete
            </button>
        </div>
    </div>
);


export const QuestLog: React.FC<QuestLogProps> = ({ items, onCompleteQuest, onStartBossBattle, onPostponeQuest, isFocusMode, onToggleFocusMode, focusQuestId, isFocusLoading, focusError }) => {
    
    const handleComplete = (e: React.MouseEvent<HTMLButtonElement>, itemId: string) => {
        onCompleteQuest(itemId);
    }
    
    const focusQuest = items.find(item => item.id === focusQuestId);
    
    return (
        <div className="p-4 sm:p-6 bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-2xl animate-fade-in-up border border-white/30 font-sans">
            <div className="flex items-center justify-between gap-3 mb-4 px-2 sm:px-0">
                <div className="flex items-center gap-3">
                    <span className="text-3xl" aria-hidden="true">üó∫Ô∏è</span>
                    <h2 id="quest-log-heading" className="text-2xl font-bold text-slate-700 font-serif">Quest Log</h2>
                </div>
                {items.length > 0 && (
                    <div className="flex items-center gap-2">
                        <label htmlFor="focus-toggle" className="text-sm font-semibold text-slate-600 cursor-pointer">Focus Mode</label>
                        <button
                            role="switch"
                            aria-checked={isFocusMode}
                            id="focus-toggle"
                            onClick={() => onToggleFocusMode(!isFocusMode)}
                            className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 ${isFocusMode ? 'bg-indigo-500' : 'bg-slate-300'}`}
                        >
                            <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${isFocusMode ? 'translate-x-6' : 'translate-x-1'}`} />
                        </button>
                    </div>
                )}
            </div>
            
            {focusError && <p className="text-red-500 text-center text-sm mb-2">{focusError}</p>}

            <div role="list" aria-labelledby="quest-log-heading" className="max-h-80 overflow-y-auto pr-2 space-y-3 custom-scrollbar">
                {isFocusLoading ? (
                    <div className="text-center py-8 px-4">
                        <p className="font-semibold text-slate-600 animate-pulse">Sonia is focusing...</p>
                    </div>
                ) : isFocusMode ? (
                    focusQuest ? (
                        <QuestItem item={focusQuest} index={0} onPostponeQuest={onPostponeQuest} onStartBossBattle={onStartBossBattle} handleComplete={handleComplete} isFocus={true} />
                    ) : (
                        <div className="text-center py-8 px-4">
                            <p className="font-semibold text-slate-600">No focus quest identified.</p>
                            <p className="text-slate-500 text-sm">Turn off Focus Mode to see all quests.</p>
                        </div>
                    )
                ) : items.length > 0 ? (
                    items.map((item, index) => (
                        <QuestItem key={item.id} item={item} index={index} onPostponeQuest={onPostponeQuest} onStartBossBattle={onStartBossBattle} handleComplete={handleComplete} />
                    ))
                ) : (
                     <div className="text-center py-8 px-4">
                        <span className="text-4xl">üßò</span>
                        <p className="mt-3 font-semibold text-slate-600">The path is clear.</p>
                        <p className="text-slate-500 text-sm">Promote an item from your inbox to start a new quest.</p>
                    </div>
                )}
            </div>
        </div>
    );
};
# AI Studio Gemini App Proxy Server

This nodejs proxy server lets you run your AI Studio Gemini application unmodified, without exposing your API key in the frontend code.


## Instructions

**Prerequisites**:
- [Google Cloud SDK / gcloud CLI](https://cloud.google.com/sdk/docs/install)
- (Optional) Gemini API Key

1. Download or copy the files of your AI Studio app into this directory at the root level.
2. If your app calls the Gemini API, create a Secret for your API key:
     ```
     echo -n "${GEMINI_API_KEY}" | gcloud secrets create gemini_api_key --data-file=-
     ```

3.  Deploy to Cloud Run (optionally including API key):
    ```
    gcloud run deploy my-app --source=. --update-secrets=GEMINI_API_KEY=gemini_api_key:latest
    ```
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});
